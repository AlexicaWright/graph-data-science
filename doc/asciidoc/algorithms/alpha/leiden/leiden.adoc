[.alpha]
[[algorithms-leiden]]
= Leiden
:entity: node
:result: community ID
:algorithm: Leiden

[abstract]
--
This section describes the Leiden algorithm in the Neo4j Graph Data Science library.
--

:undirected:
:homogeneous:
:weighted:
include::../../shared/algorithm-traits.adoc[]

[[algorithms-leiden-intro]]
== Introduction

The Leiden method is an algorithm to detect communities in large networks.
It maximizes a modularity score for each community, where the modularity quantifies the quality of an assignment of nodes to communities.
This means evaluating how much more densely connected the nodes within a community are, compared to how connected they would be in a random network.

The Leiden algorithm is a hierarchical clustering algorithm, that recursively merges communities into a single node and executes the modularity clustering on the condensed graphs.

For more information on this algorithm, see:

* https://arxiv.org/pdf/1810.08473.pdf[V.A. Traag, L. Waltman and N.J. van Eck "From Louvain to Leiden: guaranteeing well-connected communities"^]

[NOTE]
====
Running this algorithm requires sufficient memory availability.
Before running this algorithm, we recommend that you read <<memory-estimation>>.
====


[[algorithms-leiden-syntax]]
== Syntax

include::../../shared/syntax-intro-named-graph.adoc[]

.Leiden syntax per mode
[.tabbed-example, caption = ]
====

[.include-with-stream]
======
.Run Leiden in stream mode on a named graph.
[source, cypher, role=noplay]
----
CALL gds.alpha.leiden.stream(
  graphName: String,
  configuration: Map
)
YIELD
  nodeId: Integer,
  communityId: Integer
----

include::../../common-configuration/common-parameters-named-graph.adoc[]

include::../../common-configuration/common-stream-stats-configuration-named-graph.adoc[]

include::specific-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name                      | Type      | Description
| nodeId                    | Integer   | Node ID.
| communityId               | Integer   | The community ID of the final level.
|===
======


[.include-with-stats]
======
.Run Leiden in stats mode on a named graph.
[source, cypher, role=noplay]
----
CALL gds.alpha.leiden.stats(
  graphName: String,
  configuration: Map
)
YIELD
  preProcessingMillis: Integer,
  computeMillis: Integer,
  postProcessingMillis: Integer,
  communityCount: Integer,
  ranLevels: Integer,
  nodeCount: Integer,
  didConverge: Boolean,
  communityDistribution: Map,
  configuration: Map
----

include::../../common-configuration/common-parameters-named-graph.adoc[]

include::../../common-configuration/common-stream-stats-configuration-named-graph.adoc[]

include::specific-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name                  | Type      | Description
| nodeCount             | Integer   | The number of nodes in the graph.
| ranLevels             | Integer   | The number of levels the algorithm actually ran.
| didConverge           | Boolean   | Indicates if the algorithm converged.
| preProcessingMillis   | Integer   | Milliseconds for preprocessing the data.
| computeMillis         | Integer   | Milliseconds for running the algorithm.
| postProcessingMillis  | Integer   | Milliseconds for computing percentiles and community count.
| communityCount        | Integer   | The number of communities found.
| communityDistribution | Map       | Map containing min, max, mean as well as p50, p75, p90, p95, p99 and p999 percentile values of community size for the last level.
| configuration         | Map       | The configuration used for running the algorithm.
|===
======

[.include-with-mutate]
======
.Run Leiden in mutate mode on a named graph.
[source, cypher, role=noplay]
----
CALL gds.alpha.leiden.mutate(
  graphName: String,
  configuration: Map
)
YIELD
  preProcessingMillis: Integer,
  computeMillis: Integer,
  mutateMillis: Integer,
  postProcessingMillis: Integer,
  communityCount: Integer,
  ranLevels: Integer,
  nodeCount: Integer,
  didConverge: Integer,
  nodePropertiesWritten: Integer,
  communityDistribution: Map,
  configuration: Map
----

include::../../common-configuration/common-parameters-named-graph.adoc[]

include::../../common-configuration/common-mutate-configuration-named-graph.adoc[]

include::specific-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name                   | Type      | Description
| nodeCount              | Integer   | Indicates if the algorithm converged.
| ranLevels              | Integer   | The number of levels the algorithm actually ran.
| didConverge            | Boolean   | Indicates if the algorithm converged.
| preProcessingMillis    | Integer   | Milliseconds for preprocessing the data.
| computeMillis          | Integer   | Milliseconds for running the algorithm.
| mutateMillis           | Integer   | Milliseconds for adding properties to the projected graph.
| postProcessingMillis   | Integer   | Milliseconds for computing percentiles and community count.
| communityCount         | Integer   | The number of communities found.
| nodePropertiesWritten  | Integer   | Number of properties added to the projected graph.
| communityDistribution  | Map       | Map containing min, max, mean as well as p50, p75, p90, p95, p99 and p999 percentile values of community size for the last level.
| configuration          | Map       | The configuration used for running the algorithm.
|===
======
====


[[algorithms-leiden-examples]]
== Examples

:algorithm-name: Leiden community detection
:graph-description: social network
:image-file: louvain.svg
include::../../shared/examples-intro.adoc[]

.The following Cypher statement will create the example graph in the Neo4j database:
[source, cypher, role=noplay setup-query]
----
CREATE
  (nAlice:User {name: 'Alice', seed: 42}),
  (nBridget:User {name: 'Bridget', seed: 42}),
  (nCharles:User {name: 'Charles', seed: 42}),
  (nDoug:User {name: 'Doug'}),
  (nMark:User {name: 'Mark'}),
  (nMichael:User {name: 'Michael'}),

  (nAlice)-[:LINK {weight: 1}]->(nBridget),
  (nAlice)-[:LINK {weight: 1}]->(nCharles),
  (nCharles)-[:LINK {weight: 1}]->(nBridget),

  (nAlice)-[:LINK {weight: 5}]->(nDoug),

  (nMark)-[:LINK {weight: 1}]->(nDoug),
  (nMark)-[:LINK {weight: 1}]->(nMichael),
  (nMichael)-[:LINK {weight: 1}]->(nMark);
----

This graph has two clusters of _Users_, that are closely connected.
Between those clusters there is one single edge.
The relationships that connect the nodes in each component have a property `weight` which determines the strength of the relationship.

We can now project the graph and store it in the graph catalog.
We load the `LINK` relationships with orientation set to `UNDIRECTED` as this works best with the Leiden algorithm.

include::../../shared/examples-named-native-note.adoc[]

.The following statement will project the graph and store it in the graph catalog.
[source, cypher, role=noplay graph-project-query]
----
CALL gds.graph.project(
    'myGraph',
    'User',
    {
        LINK: {
            orientation: 'UNDIRECTED'
        }
    },
    {
        nodeProperties: 'seed',
        relationshipProperties: 'weight'
    }
)
----

In the following examples we will demonstrate using the Leiden algorithm on this graph.


[[algorithms-leiden-examples-stream]]
=== Stream

include::../../shared/examples-stream-intro.adoc[]

[role=query-example]
--
.The following will run the algorithm and stream results:
[source, cypher, role=noplay]
----
CALL gds.alpha.leiden.stream('myGraph', { randomSeed: 19 })
YIELD nodeId, communityId
RETURN gds.util.asNode(nodeId).name AS name, communityId
ORDER BY name ASC
----

.Results
[opts="header"]
|===
| name      | communityId
| "Alice"   | 2
| "Bridget" | 2
| "Charles" | 2
| "Doug"    | 4
| "Mark"    | 4
| "Michael" | 4
|===
--

We use default values for the procedure configuration parameter.
Levels and `innerIterations` are set to 10 and the tolerance value is 0.0001.
Because we did not set the value of `includeIntermediateCommunities` to `true`, the column communities is always `null`.


[[algorithms-leiden-examples-stats]]
=== Stats

:stats-syntax: algorithms-leiden-syntax
include::../../shared/examples-stats-intro.adoc[]

[role=query-example]
--
.The following will run the algorithm and returns the result in form of statistical and measurement values
[source, cypher, role=noplay]
----
CALL gds.alpha.leiden.stats('myGraph', { randomSeed: 19 })
YIELD communityCount
----

.Results
[opts="header",cols="1"]
|===
| communityCount
| 2
|===
--


[[algorithms-leiden-examples-mutate]]
=== Mutate

include::../../shared/examples-mutate-intro.adoc[]

[role=query-example]
--
.The following will run the algorithm and store the results in `myGraph`:
[source, cypher, role=noplay]
----
CALL gds.alpha.leiden.mutate('myGraph', { mutateProperty: 'communityId', randomSeed: 19 })
YIELD communityCount
----

.Results
[opts="header"]
|===
| communityCount
| 2
|===
--

In `mutate` mode, only a single row is returned by the procedure.
The result contains meta information, like the number of identified communities and the modularity values.
In contrast to the `write` mode the result is written to the GDS in-memory graph instead of the Neo4j database.


[[algorithms-leiden-examples-stream-weighted]]
=== Weighted

The Leiden algorithm can also run on weighted graphs, taking the given relationship weights into concern when calculating the modularity.

[role=query-example]
--
.The following will run the algorithm on a weighted graph and stream results:
[source, cypher, role=noplay]
----
CALL gds.alpha.leiden.stream('myGraph', { relationshipWeightProperty: 'weight', randomSeed: 19 })
YIELD nodeId, communityId
RETURN gds.util.asNode(nodeId).name AS name, communityId
ORDER BY name ASC
----

.Results
[opts="header"]
|===
| name      | communityId
| "Alice"   | 3
| "Bridget" | 2
| "Charles" | 2
| "Doug"    | 3
| "Mark"    | 5
| "Michael" | 5
|===
--

Using the weighted relationships, we see that `Alice` and `Doug` have formed their own community, as their link is much stronger than all the others.
