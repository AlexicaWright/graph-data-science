[[catalog-graph-create]]
= Creating graphs

[abstract]
--
A projected graph can be stored in the catalog under a user-defined name.
Using that name, the graph can be referred to by any algorithm in the library.
This allows multiple algorithms to use the same graph without having to re-create it on each algorithm run.
--

//[NOTE]
//====
//There is also a way to generate a random graph, see <<graph-generation, Graph Generation>> documentation for more details.
//====

[[graph-create-native]]
== Native Projection

Provides the best performance by reading from the Neo4j store files.
Recommended to be used during both the development and the production phase.

A native projection takes three mandatory arguments: `graphName`, `nodeProjection` and `relationshipProjection`.
In addition, the optional `configuration` parameter allows us to further configure graph creation.

[[graph-create-native-syntax]]
=== Syntax

[.graph-create-syntax]
--
[source, cypher, role=noplay]
----
CALL gds.graph.create(
    graphName: String,
    nodeProjection: String, List or Map,
    relationshipProjection: String, List or Map,
    configuration: Map
)
YIELD
  graphName: String,
  nodeProjection: Map,
  nodeCount: Integer,
  relationshipProjection: Map,
  relationshipCount: Integer,
  createMillis: Integer
----

NOTE: To get information about a stored named graph, including its schema, one can use <<catalog-graph-list, gds.graph.list>>.

.Parameters
[opts="header",cols="1,1,1, 4"]
|===
| Name                  | Type                | Optional | Description
| graphName             | String              | no       | The name under which the graph is stored in the catalog.
| nodeProjection        | String, List or Map | no       | One or more <<node-projection-syntax, node projections>>.
| relationshipProjection| String, List or Map | no       | One or more <<relationship-projection-syntax, relationship projections>>.
| configuration         | Map                 | yes      | Additional parameters to configure the native projection.
|===

.Configuration
[opts="header",cols="1,1,1,4"]
|===
| Name                   | Type                  | Default | Description
| readConcurrency        | Integer               | 4       | The number of concurrent threads used for creating the graph.
| nodeProperties         | String, List or Map   | {}      | Node properties to load for _all_ node projections.
| relationshipProperties | String, List or Map   | {}      | Relationship properties to load for _all_ relationship projections.
| validateRelationships  | Boolean               | false   | Whether to throw an error if relationships contain nodes not included in the nodeProjection.
|===

.Results
[opts="header",cols="2,1,4"]
|===
| Name                   | Type     | Description
| graphName              | String   | The name under which the graph is stored in the catalog.
| nodeProjection         | Map      | The <<node-projection-syntax, node projections>> used to project the graph.
| nodeCount              | Integer  | The number of nodes stored in the projected graph.
| relationshipProjection | Map      | The <<relationship-projection-syntax, relationship projections>> used to project the graph.
| relationshipCount      | Integer  | The number of relationships stored in the projected graph.
| createMillis           | Integer  | Milliseconds for creating the graph.
|===
--


[[node-projection-syntax]]
==== Node Projection
// Node Projection
.Short-hand String-syntax for `nodeProjection`. The projected graph will contain the given `neo4j-label`.
----
<neo4j-label>
----

.Short-hand List-syntax for `nodeProjection`. The projected graph will contain the given `neo4j-label`s.
----
[<neo4j-label>, ..., <neo4j-label>]
----

.Extended Map-syntax for `nodeProjection`.
----
{
    <projected-label>: {
        label: <neo4j-label>,
        properties: <neo4j-property-key>
    },
    <projected-label>: {
        label: <neo4j-label>,
        properties: [<neo4j-property-key>, <neo4j-property-key>, ...]
    },
    ...
    <projected-label>: {
        label: <neo4j-label>,
        properties: {
            <projected-property-key>: {
                property: <neo4j-property-key>,
                defaultValue: <fallback-value>
            },
            ...
            <projected-property-key>: {
                property: <neo4j-property-key>,
                defaultValue: <fallback-value>
            }
        }
    }
}
----

.Node Projection fields
[opts="header",cols="1,1,1,2,4"]
|===
| Name                     | Type                               | Optional | Default                  | Description
| <projected-label>        | String                             |  no      | n/a                      |The node label in the projected graph.
| label                    | String                             |  yes     | `projected-label`        |The node label in the Neo4j graph. If not set, uses the `projected-label`.
| properties               | Map, List or String                |  yes     | {}                       |The projected node properties for the specified `projected-label`.
| <projected-property-key> | String                             |  no      | n/a                      |The key for the node property in the projected graph.
| property                 | String                             |  yes     | `projected-property-key` |The node property key in the Neo4j graph. If not set, uses the `projected-property-key`.
.4+^.^| defaultValue       | Float                        .4+^.^|  yes     | `Double.NaN`          .4+|The default value if the property is not defined for a node.
|Float[]   | null
|Integer   |`Integer.MIN_VALUE`
|Integer[] | null

|===

[[relationship-projection-syntax]]
==== Relationship Projection

.Short-hand String-syntax for `relationshipProjection`. The projected graph will contain the given `neo4j-type`.
----
<neo4j-type>
----

.Short-hand List-syntax for `relationshipProjection`. The projected graph will contain the given `neo4j-type`s.
----
[<neo4j-type>, ..., <neo4j-type>]
----

.Extended Map-syntax for `relationshipProjection`.
----
{
    <projected-type>: {
        type: <neo4j-type>,
        orientation: <orientation>,
        aggregation: <aggregation-type>,
        properties: <neo4j-property-key>
    },
    <projected-type>: {
        type: <neo4j-type>,
        orientation: <orientation>,
        aggregation: <aggregation-type>,
        properties: [<neo4j-property-key>, <neo4j-property-key>]
    },
    ...
    <projected-type>: {
        type: <neo4j-type>,
        orientation: <orientation>,
        aggregation: <aggregation-type>,
        properties: {
            <projected-property-key>: {
                property: <neo4j-property-key>,
                defaultValue: <fallback-value>,
                aggregation: <aggregation-type>
            },
            ...
            <projected-property-key>: {
                property: <neo4j-property-key>,
                defaultValue: <fallback-value>,
                aggregation: <aggregation-type>
            }
        }
    }
}
----

.Relationship Projection fields
[opts="header",cols="2,1,1,3,4"]
|===
| Name                      | Type                | Optional | Default          | Description
| <projected-type>          | String              |  no      | n/a              | The name of the relationship type in the projected graph.
| type                      | String              |  yes     | `projected-type` |The relationship type in the Neo4j graph.
| orientation               | String              |  yes     |  `NATURAL`       | Denotes how Neo4j relationships are represented in the projected graph. Allowed values are `NATURAL`, `UNDIRECTED`, `REVERSE`.
| aggregation               | String              |  no      |  `NONE`          | Handling of parallel relationships. Allowed values are `NONE`, `MIN`, `MAX`, `SUM`, `SINGLE`, `COUNT`.
| properties                | Map, List or String |  yes     |  {}              |The projected relationship properties for the specified `projected-type`.
| <projected-property-key>  | String              |  no      | n/a              |The key for the relationship property in the projected graph.
| property                  | String              |  yes     | `projected-property-key` |The node property key in the Neo4j graph. If not set, uses the `projected-property-key`.
| defaultValue              | Float or Integer    |  yes     |  `Double.NaN`    | The default value if the property is not defined for a node.
|===

[[graph-create-cypher]]
== Cypher Projection

The more flexible, expressive approach with lesser focus on performance.
Recommended to be primarily used during the development phase.

[[graph-create-cypher-syntax]]
=== Syntax

A Cypher projection takes three mandatory arguments: `graphName`, `nodeQuery` and `relationshipQuery`.
In addition, the optional `configuration` parameter allows us to further configure graph creation.

[.graph-create-cypher-syntax]
--
[source, cypher, role=noplay]
----
CALL gds.graph.create.cypher(
    graphName: String,
    nodeQuery: String,
    relationshipQuery: String,
    configuration: Map
)
YIELD
    graphName: String,
    nodeQuery: String,
    nodeCount: Integer,
    relationshipQuery: String,
    relationshipCount: Integer,
    createMillis: Integer
----

.Parameters
[opts="header",cols="1,1,8"]
|===
| Name              | Optional | Description
| graphName         | no       | The name under which the graph is stored in the catalog.
| nodeQuery         | no       | Cypher query to project nodes. The query result must contain an `id` column. Optionally, a `labels` column can be specified to represent node labels. Additional columns are interpreted as properties.
| relationshipQuery | no       | Cypher query to project relationships. The query result must contain `source` and `target` columns. Optionally, a `type` column can be specified to represent relationship type. Additional columns are interpreted as properties.
| configuration     | yes      | Additional parameters to configure the Cypher projection.
|===

.Configuration
[opts="header",cols="1,1,1,4"]
|===
| Name                   | Type    | Default        | Description
| readConcurrency        | Integer | 4              | The number of concurrent threads used for creating the graph.
| validateRelationships  | Boolean | true           | Whether to throw an error if relationships contain nodes not included in the nodeQuery.
| parameters             | Map     | {}             | A map of user-defined query parameters that are passed into the node and relationship query.
|===

.Results
[opts="header",cols="2,1,4"]
|===
| Name                   | Type     | Description
| graphName              | String   | The name under which the graph is stored in the catalog.
| nodeQuery              | String   | The cypher query used to project the nodes in the graph.
| nodeCount              | Integer  | The number of nodes stored in the projected graph.
| relationshipQuery      | String   | The cypher query used to project the relationships in the graph.
| relationshipCount      | Integer  | The number of relationships stored in the projected graph.
| createMillis           | Integer  | Milliseconds for creating the graph.
|===
--

// TODO put this into a life-cycle subsection
[NOTE]
--
The projected graphs will reside in the catalog until:

- the graph is dropped using <<catalog-graph-drop, gds.graph.drop>>
- the Neo4j database from which to graph was projected is stopped or dropped
- the Neo4j database management system is stopped.
--

NOTE: To get information about a stored named graph, including its schema, one can use <<catalog-graph-list, gds.graph.list>>.

[[graph-create-examples]]
== Examples

In order to demonstrate the GDS Graph Create capabilities we are going to create a small social network graph in Neo4j.
The example graph looks like this:

image::example-graphs/graph-create-example.svg[Visualization of the example graph,align="center"]

.The following Cypher statement will create the example graph in the Neo4j database:
[source, cypher, role=noplay setup-query]
----
CREATE
  (florentin:Person { name: 'Florentin', age: 16 }),
  (adam:Person { name: 'Adam', age: 18 }),
  (veselin:Person { name: 'Veselin', age: 20, ratings: [5.0] }),
  (hobbit:Book { name: 'The Hobbit', isbn: 1234, numberOfPages: 310, ratings: [1.0, 2.0, 3.0, 4.5] }),
  (frankenstein:Book { name: 'Frankenstein', isbn: 4242, price: 19.99 }),
  (florentin)-[:KNOWS { since: 2010 }]->(adam),
  (florentin)-[:KNOWS { since: 2018 }]->(veselin),
  (florentin)-[:READ { numberOfPages: 4 }]->(hobbit),
  (florentin)-[:READ { numberOfPages: 42 }]->(hobbit),
  (adam)-[:READ { numberOfPages: 30 }]->(hobbit),
  (veselin)-[:READ]->(frankenstein)
----

[[graph-create-example-single-label-type]]
=== Projecting a label and relationship type

We are going to start with demonstrating how to load a single `label` and `relationship` by projecting only the `Person` label and `KNOWS` relationship type.

[.tabbed-example]
====

[.include-with-native-projection]
======

[role=query-example]
--
.Project and store `PERSON` nodes and `KNOWS` relationships into a `persons` graph.
[source, cypher, role=noplay]
----
CALL gds.graph.create('persons', 'Person', 'KNOWS')
YIELD
  graphName AS graph, nodeProjection, nodeCount AS nodes, relationshipProjection, relationshipCount AS rels
----

.Results
[opts="header", cols="1,3m,1,3m,1m"]
|===
| graph     | nodeProjection                         | nodes  | relationshipProjection                                                        | rels
| "persons" | {Person={label=Person, properties={}}} | 3      | {KNOWS={orientation=NATURAL, aggregation=DEFAULT, type=KNOWS, properties={}}} | 2
|===
--

In the example above, we used a `short-hand` syntax for the node and relationship projection.
The used projections are internally expanded to the full `Map` syntax as shown in the `Results` table.
In addition, we can see the projected in-memory graph contains three `Person` nodes, and the two `KNOWS` relationships.
======

[.include-with-cypher-projection]
======

[role=query-example]
--
.Project and store `PERSON` nodes and `KNOWS` relationships into a `persons` graph.
[source, cypher, role=noplay]
----
CALL gds.graph.create.cypher(
  'persons',
  'MATCH (n:Person) RETURN id(n) AS id',
  'MATCH (n:Person)-[r:KNOWS]->(m:Person) RETURN id(n) AS source, id(m) AS target')
YIELD
  graphName AS graph, nodeQuery, nodeCount AS nodes, relationshipQuery, relationshipCount AS rels
----

.Results
[opts="header", cols="1,3m,1,3m,1m"]
|===
| graph     | nodeQuery                             | nodes  | relationshipQuery                                                                | rels
| "persons" | "MATCH (n:Person) RETURN id(n) AS id" | 3      | "MATCH (n:Person)-[r:KNOWS]->(m:Person) RETURN id(n) AS source, id(m) AS target" | 2
|===
--

// TODO: Add analysis here

======
====


// 1. the very simple case, List of Strings --> Labels & Rels, no properties
=== Projecting multiple labels and relationship types

[.tabbed-example]
====

[.include-with-native-projection]
======
To project multiple node labels and relationship types, we can adjust the projections as follows:

[role=query-example]
--
.Project and store `PERSON` and `Book` nodes and `KNOWS` and `READ` relationships into a `personsAndBooks` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.create('personsAndBooks', ['Person', 'Book'], ['KNOWS', 'READ'])
YIELD
  graphName AS graph, nodeProjection, nodeCount AS nodes, relationshipCount AS rels
----

.Results
[opts="header", cols="1,3m,1m,1m"]
|===
| graph             | nodeProjection                                                           | nodes  | rels
| "personsAndBooks" | {Book={label=Book, properties={}}, Person={label=Person, properties={}}} | 5      | 6
|===
--

In the example above, we used a `short-hand` syntax for the node- and relationship projection.
The used projections are internally expanded to the full `Map` syntax as shown for the `nodeProjection` in the `Results` table.
In addition, we can see the projected in-memory graph contains five nodes, and the two relationships.
======

[.include-with-cypher-projection]
======
To retain the label and type information, when we load multiple node labels and relationship types, we can add a `labels` column to the node query and `type` column to the relationship query.

[role=query-example]
--
.Project and store `PERSON` and `Book` nodes and `KNOWS` and `READ` relationships into a `personsAndBooks` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.create.cypher(
  'personsAndBooks',
  'MATCH (n) RETURN id(n) AS id, labels(n) AS labels',
  'MATCH (n)-[r:KNOWS|READ]->(m) RETURN id(n) AS source, id(m) AS target, type(r) AS type')
YIELD
  graphName AS graph, nodeQuery, nodeCount AS nodes, relationshipCount AS rels
----

.Results
[opts="header", cols="1,3m,1m,1m"]
|===
| graph             | nodeQuery                                           | nodes  | rels
| "personsAndBooks" | "MATCH (n) RETURN id(n) AS id, labels(n) AS labels" | 5      | 6
|===
--
======
====


=== Changing the orientation of relationships

==== Native-projection

By default, relationships are loaded in the same orientation as stored in the Neo4j db.
In GDS, we call this the `NATURAL` orientation.
Additionally, we provide the functionality to load the relationships in the `REVERSE` orientation or even `UNDIRECTED`.

[role=query-example]
--
.Project and store `PERSON` nodes and undirected `KNOWS` relationships into a `undirectedKnows` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.create('undirectedKnows', 'Person', {KNOWS: {orientation: 'UNDIRECTED'}})
YIELD
  graphName AS graph, relationshipProjection AS knowsProjection, nodeCount AS nodes, relationshipCount AS rels
----

.Results
[opts="header", cols="1,3m,1m,1m"]
|===
| graph             | knowsProjection                                                                  | nodes  | rels
| "undirectedKnows" | {KNOWS={orientation=UNDIRECTED, aggregation=DEFAULT, type=KNOWS, properties={}}} | 3      | 4
|===
--

To specify the orientation, we need to write the `relationshipProjection` with extended Map-syntax.
Projecting the `KNOWS` relationships `UNDIRECTED`, loads each relationship in both directions.
Thus, the `undirectedKnows` graph contains four relationships, twice as many as the `persons` graph in <<graph-create-example-single-label-type>>.


==== Cypher-projection

The native projection supports specifying an orientation per relationship type.
The cypher projection will treat every relationship returned by the relationship cypher query as if it was in `NATURAL` orientation.
It is thus not possible to project graphs in `UNDIRECTED` or `REVERSE` orientation when cypher projections are used.

[NOTE]
--
Some algorithms require that the graph was loaded with `UNDIRECTED` orientation.
These algorithms can not be used when loading a graph with cypher projections.
--

[[node-properties-example]]
=== Projecting node properties

==== Native-projection

To project node properties we can either use the `nodeProperties` configuration parameter or extend an individual `nodeProjection` for a specific label.

[role=query-example, group=node-properties]
--
.Project and store `PERSON` and `Book` nodes and `KNOWS` and `READ` relationships into a `personsAndBooks` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.create('graphWithProperties', {Person: {properties: 'age'}, Book: {properties: {price: {defaultValue: 5.0}}}}, ['KNOWS', 'READ'], {nodeProperties: 'ratings'})
YIELD
  graphName, nodeProjection, nodeCount AS nodes, relationshipCount AS rels
RETURN graphName, nodeProjection.Book AS bookProjection, nodes, rels
----

.Results
[opts="header", cols="1,3m,1m,1m"]
|===
| graphName             | bookProjection                                                           | nodes  | rels
| "graphWithProperties" | {label=Book, properties={price={defaultValue=5.0, property=price}, ratings={defaultValue=null, property=ratings}}} | 5      | 6
|===
--

The projected `graphWithProperties` graph contains five nodes and six relationships.
In the returned `bookProjection` we can observe, the node properties `price` and `ratings` are loaded for `Books`.

NOTE: GDS currently only supports loading numeric properties.

Further, the `price` property has a default value of `5.0`.
Not every book has a price specified in the example graph.
In the following we check if the price was correctly projected:

[role=query-example, group=node-properties]
--
.Verify the ratings property of Adam in the projected `graphWithProperties` graph:
[source, cypher, role=noplay]
----
MATCH (n:Book)
RETURN n.name AS name, gds.util.nodeProperty('graphWithProperties', id(n), 'price') as price
ORDER BY price
----

.Results
[opts="header", cols="1,1"]
|===
| name          | price
| "The Hobbit"  | 5.0
| "Frankenstein"| 19.99
|===
--

We can see, that the price was projected with the Hobbit having the default price of 5.0.

==== Cypher-projection

[role=query-example, group=cypher-node-properties]
--
.Project and store `PERSON` and `Book` nodes and `KNOWS` and `READ` relationships into a `personsAndBooks` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.create.cypher(
  'graphWithProperties',
  'MATCH (n) RETURN
    id(n) AS id,
    labels(n) AS labels,
    coalesce(n.age, 18) AS age,
    coalesce(n.price, 5.0) AS price,
    n.ratings AS ratings',
  'MATCH (n)-[r:KNOWS|READ]->(m) RETURN id(n) AS source, id(m) AS target, type(r) AS type'
)
YIELD
  graphName, nodeCount AS nodes, relationshipCount AS rels
RETURN graphName, nodes, rels
----

.Results
[opts="header", cols="1,1,1"]
|===
| graphName             | nodes  | rels
| "graphWithProperties" | 5      | 6
|===
--

The projected `graphWithProperties` graph contains five nodes and six relationships.
In Cypher projection every node from the `nodeQuery` gets the same node properties, which means you can't have label-specific properties.
For instance in the example above the `Person` nodes will also get `ratings` and `price` properties, while `Book` nodes get the `age` property.

NOTE: GDS currently only supports loading numeric properties.

Further, the `price` property has a default value of `5.0`.
Not every book has a price specified in the example graph.
In the following we check if the price was correctly projected:

[role=query-example, group=cypher-node-properties]
--
.Verify the ratings property of Adam in the projected `graphWithProperties` graph:
[source, cypher, role=noplay]
----
MATCH (n:Book)
RETURN n.name AS name, gds.util.nodeProperty('graphWithProperties', id(n), 'price') as price
ORDER BY price
----

.Results
[opts="header", cols="1,1"]
|===
| name          | price
| "The Hobbit"  | 5.0
| "Frankenstein"| 19.99
|===
--

We can see, that the price was projected with the Hobbit having the default price of 5.0.


=== Projecting relationship properties

==== Native-projection

Analogous to node properties, we can either use the `relationshipProperties` configuration parameter or extend an individual `relationshipProjection` for a specific type.

[role=query-example, group=rel-properties]
--
.Project a `readWithProperties` graph containing `Person` and `Book` nodes and `READ` relationships with `numberOfPages`:
[source, cypher, role=noplay]
----
CALL gds.graph.create('readWithProperties', ['Person', 'Book'], {READ: {properties: "numberOfPages"}})
YIELD
  graphName AS graph, relationshipProjection AS readProjection, nodeCount AS nodes, relationshipCount AS rels
----

.Results
[opts="header", cols="1,3m,1m,1m"]
|===
| graph      | readProjection                                                                  | nodes  | rels
| "readWithProperties" | {READ={orientation=NATURAL, aggregation=DEFAULT, type=READ, properties={numberOfPages={defaultValue=null, property=numberOfPages, aggregation=DEFAULT}}}} | 5      | 4
|===
--

Next, we will verify that the relationship property `numberOfPages` were correctly loaded.

[role=query-example, group=rel-properties]
--
.Stream the relationship property `numberOfPages` of the projected `readWithProperties` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.streamRelationshipProperty('readWithProperties', 'numberOfPages')
YIELD sourceNodeId, targetNodeId, propertyValue AS numberOfPages
RETURN gds.util.asNode(sourceNodeId).name AS person, gds.util.asNode(targetNodeId).name AS book, numberOfPages
ORDER BY person ASC, numberOfPages DESC
----

.Results
[opts="header", cols="1,1,1"]
|===
| person      | book                 | numberOfPages
| "Adam"      |  "The Hobbit"        | 30.0
| "Florentin" |  "The Hobbit"        | 42.0
| "Florentin" |  "The Hobbit"        | 4.0
| "Veselin"   |  "Frankenstein"      | NaN
|===
--

We can see, that the `numberOfPages` are loaded. The default property value is `Double.Nan` and can be changed using the Map-Syntax the same as for node properties in <<node-properties-example>>.


==== Cypher-projection

Analogous to node properties, we can project relationship properties using the `relationshipQuery`.

[role=query-example, group=cypher-rel-properties]
--
.Project a `readWithProperties` graph containing `Person` and `Book` nodes and `READ` relationships with `numberOfPages`:
[source, cypher, role=noplay]
----
CALL gds.graph.create.cypher(
  'readWithProperties',
  'MATCH (n) RETURN id(n) AS id, labels(n) AS labels',
  'MATCH (n)-[r:READ]->(m) RETURN id(n) AS source, id(m) AS target, type(r) AS type, r.numberOfPages AS numberOfPages'
)
YIELD
  graphName AS graph, nodeCount AS nodes, relationshipCount AS rels
----

.Results
[opts="header", cols="1,1,1"]
|===
| graph                | nodes  | rels
| "readWithProperties" | 5      | 4
|===
--

Next, we will verify that the relationship property `numberOfPages` were correctly loaded.

[role=query-example, group=cypher-rel-properties]
--
.Stream the relationship property `numberOfPages` of the projected `readWithProperties` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.streamRelationshipProperty('readWithProperties', 'numberOfPages')
YIELD sourceNodeId, targetNodeId, propertyValue AS numberOfPages
RETURN gds.util.asNode(sourceNodeId).name AS person, gds.util.asNode(targetNodeId).name AS book, numberOfPages
ORDER BY person ASC, numberOfPages DESC
----

.Results
[opts="header", cols="1,1,1"]
|===
| person      | book                 | numberOfPages
| "Adam"      |  "The Hobbit"        | 30.0
| "Florentin" |  "The Hobbit"        | 42.0
| "Florentin" |  "The Hobbit"        | 4.0
| "Veselin"   |  "Frankenstein"      | NaN
|===
--

We can see, that the `numberOfPages` are loaded. The default property value is `Double.Nan` and can be changed using the Map-Syntax the same as for node properties in <<node-properties-example>>.

=== Handling parallel relationships

Neo4j supports parallel relationships, i.e., multiple relationships between two nodes.
By default, GDS preserves the parallel relationships.
For some algorithms, we want the projected graph to contain at most one relationship between two nodes.

==== Native-projection

We can specify how parallel relationships should be merged into a single relationship via the `aggregation` parameter in a relationship projection.

For graphs without relationship properties, we can use the `COUNT` aggregation.

// special case: COUNT example
[role=query-example, group=count-aggregate]
--
.Project a `readCount` graph containing `Person` and `Book` nodes and `COUNT` aggregated `READ` relationships:
[source, cypher, role=noplay]
----
CALL gds.graph.create('readCount', ['Person', 'Book'], {READ: {properties: {numberOfReads: {property:'*', aggregation: 'COUNT'}}}})
YIELD
  graphName AS graph, relationshipProjection AS readProjection, nodeCount AS nodes, relationshipCount AS rels
----

.Results
[opts="header", cols="1,3m,1m,1m"]
|===
| graph      | readProjection                                                                  | nodes  | rels
| "readCount" | {READ={orientation=NATURAL, aggregation=DEFAULT, type=READ, properties={numberOfReads={defaultValue=null, property=*, aggregation=COUNT}}}} | 5      | 3
|===
--

Next, we will verify that the `READ` relationships were correctly aggregated.

[role=query-example, group=count-aggregate]
--
.Stream the relationship property `numberOfReads` of the projected `readCount` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.streamRelationshipProperty('readCount', 'numberOfReads')
YIELD sourceNodeId, targetNodeId, propertyValue AS numberOfReads
RETURN gds.util.asNode(sourceNodeId).name AS person, gds.util.asNode(targetNodeId).name AS book, numberOfReads
ORDER BY numberOfReads DESC, person
----

.Results
[opts="header", cols="1,1,1"]
|===
| person      | book                  | numberOfReads
| "Florentin" |  "The Hobbit"        | 2.0
| "Adam"      |  "The Hobbit"        | 1.0
| "Veselin"   |  "Frankenstein"      | 1.0
|===
--

We can see, that the two READ relationships between Florentin and the Hobbit result in `2` numberOfReads.

==== Cypher-projection

The simplest way to achieve relationship deduplication is to use the `DISTINCT` operator in the relationship query.
Another way to do this is to project the parallel relationship count as a relationship properties.

// special case: COUNT example
[role=query-example, group=cypher-count-aggregate]
--
.Project a `readCount` graph containing `Person` and `Book` nodes and `COUNT` aggregated `READ` relationships:
[source, cypher, role=noplay]
----
CALL gds.graph.create.cypher(
  'readCount',
  'MATCH (n) RETURN id(n) AS id, labels(n) AS labels',
  'MATCH (n)-[r:READ]->(m) RETURN id(n) AS source, id(m) AS target, type(r) AS type, count(r) AS numberOfReads'
)
YIELD
  graphName AS graph, nodeCount AS nodes, relationshipCount AS rels
----

.Results
[opts="header", cols="1,1,1"]
|===
| graph       | nodes  | rels
| "readCount" | 5      | 3
|===
--

Next, we will verify that the `READ` relationships were correctly aggregated.

[role=query-example, group=cypher-count-aggregate]
--
.Stream the relationship property `numberOfReads` of the projected `readCount` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.streamRelationshipProperty('readCount', 'numberOfReads')
YIELD sourceNodeId, targetNodeId, propertyValue AS numberOfReads
RETURN gds.util.asNode(sourceNodeId).name AS person, gds.util.asNode(targetNodeId).name AS book, numberOfReads
ORDER BY numberOfReads DESC, person
----

.Results
[opts="header", cols="1,1,1"]
|===
| person      | book                  | numberOfReads
| "Florentin" |  "The Hobbit"        | 2.0
| "Adam"      |  "The Hobbit"        | 1.0
| "Veselin"   |  "Frankenstein"      | 1.0
|===
--

We can see, that the two READ relationships between Florentin and the Hobbit result in `2` numberOfReads.


=== Handling parallel relationships with properties

==== Native-projection

For graphs with relationship properties we can also use other aggregations.

[role=query-example, group=sum-aggregate]
--
.Project a `readSums` graph containing `Person` and `Book` nodes and aggregated `READ` relationships by summing the `numberOfPages`:
[source, cypher, role=noplay]
----
CALL gds.graph.create(
  'readSums',
  ['Person', 'Book'],
  {READ: {properties: {numberOfPages: {aggregation: 'SUM'}}}}
)
YIELD
  graphName AS graph,
  relationshipProjection AS readProjection,
  nodeCount AS nodes,
  relationshipCount AS rels
----

.Results
[opts="header", cols="1,3m,1m,1m"]
|===
| graph      | readProjection                                                                  | nodes  | rels
| "readSums" | {READ={orientation=NATURAL, aggregation=DEFAULT, type=READ, properties={numberOfPages={defaultValue=null, property=numberOfPages, aggregation=SUM}}}} | 5      | 3
|===
--

Next, we will verify that the relationship property `numberOfPages` were correctly aggregated.

[role=query-example, group=sum-aggregate]
--
.Stream the relationship property `numberOfPages` of the projected `readSums` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.streamRelationshipProperty('readSums', 'numberOfPages')
YIELD
  sourceNodeId, targetNodeId, propertyValue AS numberOfPages
RETURN
  gds.util.asNode(sourceNodeId).name AS person,
  gds.util.asNode(targetNodeId).name AS book,
  numberOfPages
ORDER BY numberOfPages DESC, person
----

.Results
[opts="header", cols="1,1,1"]
|===
| person      | book                 | numberOfPages
| "Florentin" |  "The Hobbit"        | 46.0
| "Adam"      |  "The Hobbit"        | 30.0
| "Veselin"   |  "Frankenstein"      | 0.0
|===
--

We can see, that the two READ relationships between Florentin and the Hobbit sum up to `46` numberOfReads.


==== Cypher-projection

For graphs with relationship properties we can also use other aggregations.

[role=query-example, group=cypher-sum-aggregate]
--
.Project a `readSums` graph containing `Person` and `Book` nodes and aggregated `READ` relationships by summing the `numberOfPages`:
[source, cypher, role=noplay]
----
CALL gds.graph.create.cypher(
  'readSums',
  'MATCH (n) RETURN id(n) AS id, labels(n) AS labels',
  'MATCH (n)-[r:READ]->(m) RETURN id(n) AS source, id(m) AS target, type(r) AS type, sum(r.numberOfPages) AS numberOfPages'
)
YIELD
  graphName AS graph, nodeCount AS nodes, relationshipCount AS rels
----

.Results
[opts="header", cols="1,1,1"]
|===
| graph      | nodes  | rels
| "readSums" | 5      | 3
|===
--

Next, we will verify that the relationship property `numberOfPages` were correctly aggregated.

[role=query-example, group=cypher-sum-aggregate]
--
.Stream the relationship property `numberOfPages` of the projected `readSums` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.streamRelationshipProperty('readSums', 'numberOfPages')
YIELD sourceNodeId, targetNodeId, propertyValue AS numberOfPages
RETURN gds.util.asNode(sourceNodeId).name AS person, gds.util.asNode(targetNodeId).name AS book, numberOfPages
ORDER BY numberOfPages DESC, person
----

.Results
[opts="header", cols="1,1,1"]
|===
| person      | book                 | numberOfPages
| "Florentin" |  "The Hobbit"        | 46.0
| "Adam"      |  "The Hobbit"        | 30.0
| "Veselin"   |  "Frankenstein"      | 0.0
|===
--

We can see, that the two READ relationships between Florentin and the Hobbit sum up to `46` numberOfReads.
