[[catalog-graph-create]]
= Creating graphs

[abstract]
--
A projected graph can be stored in the catalog under a user-defined name.
Using that name, the graph can be referred to by any algorithm in the library.
This allows multiple algorithms to use the same graph without having to re-create it on each algorithm run.
--

//[NOTE]
//====
//There is also a way to generate a random graph, see <<graph-generation, Graph Generation>> documentation for more details.
//====

== Native Projection

Provides the best performance by reading from the Neo4j store files.
Recommended to be used during both the development and the production phase.

A native projection takes three mandatory arguments: `graphName`, `nodeProjection` and `relationshipProjection`.
In addition, the optional `configuration` parameter allows us to further configure graph creation.

[[graph-create-native-syntax]]
=== Syntax

[.graph-create-syntax]
--
[source, cypher, role=noplay]
----
CALL gds.graph.create(
    graphName: String,
    nodeProjection: String, List or Map,
    relationshipProjection: String, List or Map,
    configuration: Map
)
YIELD
  graphName: String,
  nodeProjection: Map,
  nodeCount: Integer,
  relationshipProjection: Map,
  relationshipCount: Integer,
  createMillis: Integer
----

NOTE: To get information about a stored named graph, including its schema, one can use <<catalog-graph-list, gds.graph.list>>.

.Parameters
[opts="header",cols="1,1,1, 4"]
|===
| Name                  | Type                | Optional | Description
| graphName             | String              | no       | The name under which the graph is stored in the catalog.
| nodeProjection        | String, List or Map | no       | One or more <<node-projection-syntax, node projections>>.
| relationshipProjection| String, List or Map | no       | One or more <<relationship-projection-syntax, relationship projections>>.
| configuration         | Map                 | yes      | Additional parameters to configure the native projection.
|===

.Configuration
[opts="header",cols="1,1,1,4"]
|===
| Name                   | Type                  | Default | Description
| readConcurrency        | Integer               | 4       | The number of concurrent threads used for creating the graph.
| nodeProperties         | String, List or Map   | {}      | Node properties to load for _all_ node projections.
| relationshipProperties | String, List or Map   | {}      | Relationship properties to load for _all_ relationship projections.
| validateRelationships  | Boolean               | false   | Whether to throw an error if relationships contain nodes not included in the nodeProjection.
|===

.Results
[opts="header",cols="2,1,4"]
|===
| Name                   | Type     | Description
| graphName              | String   | The name under which the graph is stored in the catalog.
| nodeProjection         | Map      | The <<node-projection-syntax, node projections>> used to project the graph.
| nodeCount              | Integer  | The number of nodes stored in the projected graph.
| relationshipProjection | Map      | The <<relationship-projection-syntax, relationship projections>> used to project the graph.
| relationshipCount      | Integer  | The number of relationships stored in the projected graph.
| createMillis           | Integer  | Milliseconds for creating the graph.
|===
--


[[node-projection-syntax]]
==== Node Projection
// Node Projection
.Short-hand String-syntax for `nodeProjection`. The projected graph will contain the given `neo4j-label`.
----
<neo4j-label>
----

.Short-hand List-syntax for `nodeProjection`. The projected graph will contain the given `neo4j-label`s.
----
[<neo4j-label>, ..., <neo4j-label>]
----

.Extended Map-syntax for `nodeProjection`.
----
{
    <projected-label>: {
        label: <neo4j-label>,
        properties: <neo4j-property-key>
    },
    <projected-label>: {
        label: <neo4j-label>,
        properties: [<neo4j-property-key>, <neo4j-property-key>, ...]
    },
    ...
    <projected-label>: {
        label: <neo4j-label>,
        properties: {
            <projected-property-key>: {
                property: <neo4j-property-key>,
                defaultValue: <fallback-value>
            },
            ...
            <projected-property-key>: {
                property: <neo4j-property-key>,
                defaultValue: <fallback-value>
            }
        }
    }
}
----

.Node Projection fields
[opts="header",cols="1,1,1,2,4"]
|===
| Name                     | Type                               | Optional | Default                  | Description
| <projected-label>        | String                             |  no      | n/a                      |The node label in the projected graph.
| label                    | String                             |  yes     | `projected-label`        |The node label in the Neo4j graph. If not set, uses the `projected-label`.
| properties               | Map, List or String                |  yes     | {}                       |The projected node properties for the specified `projected-label`.
| <projected-property-key> | String                             |  no      | n/a                      |The key for the node property in the projected graph.
| property                 | String                             |  yes     | `projected-property-key` |The node property key in the Neo4j graph. If not set, uses the `projected-property-key`.
.4+^.^| defaultValue       | Float                        .4+^.^|  yes     | `Double.NaN`          .4+|The default value if the property is not defined for a node.
|Float[]   | null
|Integer   |`Integer.MIN_VALUE`
|Integer[] | null

|===

[[relationship-projection-syntax]]
==== Relationship Projection

.Short-hand String-syntax for `relationshipProjection`. The projected graph will contain the given `neo4j-type`.
----
<neo4j-type>
----

.Short-hand List-syntax for `relationshipProjection`. The projected graph will contain the given `neo4j-type`s.
----
[<neo4j-type>, ..., <neo4j-type>]
----

.Extended Map-syntax for `relationshipProjection`.
----
{
    <projected-type>: {
        type: <neo4j-type>,
        orientation: <orientation>,
        aggregation: <aggregation-type>,
        properties: <neo4j-property-key>
    },
    <projected-type>: {
        type: <neo4j-type>,
        orientation: <orientation>,
        aggregation: <aggregation-type>,
        properties: [<neo4j-property-key>, <neo4j-property-key>]
    },
    ...
    <projected-type>: {
        type: <neo4j-type>,
        orientation: <orientation>,
        aggregation: <aggregation-type>,
        properties: {
            <projected-property-key>: {
                property: <neo4j-property-key>,
                defaultValue: <fallback-value>,
                aggregation: <aggregation-type>
            },
            ...
            <projected-property-key>: {
                property: <neo4j-property-key>,
                defaultValue: <fallback-value>,
                aggregation: <aggregation-type>
            }
        }
    }
}
----

.Relationship Projection fields
[opts="header",cols="2,1,1,3,4"]
|===
| Name                      | Type                | Optional | Default          | Description
| <projected-type>          | String              |  no      | n/a              | The name of the relationship type in the projected graph.
| type                      | String              |  yes     | `projected-type` |The relationship type in the Neo4j graph.
| orientation               | String              |  yes     |  `NATURAL`       | Denotes how Neo4j relationships are represented in the projected graph. Allowed values are `NATURAL`, `UNDIRECTED`, `REVERSE`.
| aggregation               | String              |  no      |  `NONE`          | Handling of parallel relationships. Allowed values are `NONE`, `MIN`, `MAX`, `SUM`, `SINGLE`, `COUNT`.
| properties                | Map, List or String |  yes     |  {}              |The projected relationship properties for the specified `projected-type`.
| <projected-property-key>  | String              |  no      | n/a              |The key for the relationship property in the projected graph.
| property                  | String              |  yes     | `projected-property-key` |The node property key in the Neo4j graph. If not set, uses the `projected-property-key`.
| defaultValue              | Float or Integer    |  yes     |  `Double.NaN`    | The default value if the property is not defined for a node.
|===


[[graph-create-examples]]
=== Examples


In order to demonstrate the GDS Graph Create capabilities we are going to create a small social network graph in Neo4j.
The example graph looks like this:

image::example-graphs/graph-create-example.svg[Visualization of the example graph,align="center"]

.The following Cypher statement will create the example graph in the Neo4j database:
[source, cypher, role=noplay setup-query]
----
CREATE
  (florentin:Person { name: 'Florentin', age: 16 }),
  (adam:Person { name: 'Adam', age: 18 }),
  (veselin:Person { name: 'Veselin', age: 20, ratings: [5.0] }),
  (hobbit:Book { name: 'The Hobbit', isbn: 1234, numberOfPages: 310, ratings: [1.0, 2.0, 3.0, 4.5] }),
  (frankenstein:Book { name: 'Frankenstein', isbn: 4242, price: 19.99 }),
  (florentin)-[:KNOWS { since: 2010 }]->(adam),
  (florentin)-[:KNOWS { since: 2018 }]->(veselin),
  (florentin)-[:READ { numberOfPages: 4 }]->(hobbit),
  (florentin)-[:READ { numberOfPages: 42 }]->(hobbit),
  (adam)-[:READ { numberOfPages: 30 }]->(hobbit),
  (veselin)-[:READ]->(frankenstein)
----

[[graph-create-example-single-label-type]]
==== Projecting a label and relationship type

We are going to start with demonstrating how to load a single `label` and `relationship` by projecting only the `Person` label and `KNOWS` relationship type.

[role=query-example]
--
.The following will project and store the `PERSON` nodes and `KNOWS` relationships into a `persons` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.create('persons', 'Person', 'KNOWS')
YIELD
  graphName AS graph, nodeProjection, nodeCount AS nodes, relationshipProjection, relationshipCount AS rels
----

.Results
[opts="header", cols="1,3m,1,3m,1m"]
|===
| graph     | nodeProjection                         | nodes  | relationshipProjection                                                        | rels
| "persons" | {Person={label=Person, properties={}}} | 3      | {KNOWS={orientation=NATURAL, aggregation=DEFAULT, type=KNOWS, properties={}}} | 2
|===
--

In the example above, we used a `short-hand` syntax for the node- and relationship projection.
The used projections are internally expanded to the full `Map` syntax as shown in the `Results` table.
In addition, we can see the projected in-memory graph contains three `Person` nodes, and the two `KNOWS` relationships.


// 1. the very simple case, List of Strings --> Labels & Rels, no properties
==== Projecting multiple labels and relationship types

To project multiple node labels and relationship types, we can adjust the projections as follows:

[role=query-example]
--
.The following will project and store the `PERSON` and `Book` nodes and the `KNOWS` and `READ` relationships into a `personsAndBooks` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.create('personsAndBooks', ['Person', 'Book'], ['KNOWS', 'READ'])
YIELD
  graphName AS graph, nodeProjection, nodeCount AS nodes, relationshipCount AS rels
----

.Results
[opts="header", cols="1,3m,1m,1m"]
|===
| graph             | nodeProjection                                                           | nodes  | rels
| "personsAndBooks" | {Book={label=Book, properties={}}, Person={label=Person, properties={}}} | 5      | 6
|===
--

In the example above, we used a `short-hand` syntax for the node- and relationship projection.
The used projections are internally expanded to the full `Map` syntax as shown for the `nodeProjection` in the `Results` table.
In addition, we can see the projected in-memory graph contains five nodes, and the two relationships.

==== Changing the orientation of relationships

By default, relationships are loaded in the same orientation as stored in the Neo4j db.
In GDS, we call this the `NATURAL` orientation.
Additionally, we provide the functionality to load the relationships in the `REVERSE` orientation or even `UNDIRECTED`.

[role=query-example]
--
.The following will project and store the `PERSON` nodes and the `KNOWS` relationships as undirected into a `undirectedKnows` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.create('undirectedKnows', 'Person', {KNOWS: {orientation: 'UNDIRECTED'}})
YIELD
  graphName AS graph, relationshipProjection AS knowsProjection, nodeCount AS nodes, relationshipCount AS rels
----

.Results
[opts="header", cols="1,3m,1m,1m"]
|===
| graph             | knowsProjection                                                                  | nodes  | rels
| "undirectedKnows" | {KNOWS={orientation=UNDIRECTED, aggregation=DEFAULT, type=KNOWS, properties={}}} | 3      | 4
|===
--

To specify the orientation, we need to write the `relationshipProjection` with extended Map-syntax.
Projecting the `KNOWS` relationships `UNDIRECTED`, loads each relationship in both directions.
Thus, the `undirectedKnows` graph contains four relationships, twice as many as the `persons` graph in <<graph-create-example-single-label-type>>.

==== Projecting node properties

To project node properties we can either use the `nodeProperties` configuration parameter or extend an individual `nodeProjection` for a specific label.

[role=query-example, group=node-properties]
--
.The following will project and store the `PERSON` and `Book` nodes and the `KNOWS` and `READ` relationships into a `personsAndBooks` graph:
[source, cypher, role=noplay]
----
CALL gds.graph.create('graphWithProperties', {Person: {properties: 'age'}, Book: {properties: {price: {defaultValue: 5.0}}}}, ['KNOWS', 'READ'], {nodeProperties: 'ratings'})
YIELD
  graphName AS graph, nodeProjection, nodeCount AS nodes, relationshipCount AS rels
RETURN graph, nodeProjection.Book AS bookProjection, nodes, rels
----

.Results
[opts="header", cols="1,3m,1m,1m"]
|===
| graph                 | bookProjection                                                           | nodes  | rels
| "graphWithProperties" | {label=Book, properties={price={defaultValue=5.0, property=price}, ratings={defaultValue=null, property=ratings}}} | 5      | 6
|===
--

The projected `graphWithProperties` graph contains five nodes and six relationships.
In the returned `bookProjection` we can observe, the node properties `price` and `ratings` are loaded for `Books`.

NOTE: GDS currently only supports loading numeric properties.

Further, the `price` property has a default value of `5.0`.
Not every book has a price specified in the example graph.
In the following we check if the price was correctly projected:

[role=query-example, group=node-properties]
--
.The following will lookup the ratings property of Adam in the projected `graphWithProperties` graph:
[source, cypher, role=noplay]
----
MATCH (n:Book)
RETURN n.name AS name, gds.util.nodeProperty('graphWithProperties', id(n), 'price') as price
ORDER BY price
----

.Results
[opts="header", cols="1,1"]
|===
| name          | price
| "The Hobbit"  | 5.0
| "Frankenstein"| 19.99
|===
--

We can see, that the price was projected with the Hobbit having the default price of 5.0.

// 3.1. very simple relationship properties only with String relationship property
// 3.2. expanded relationship properties with default value and different name
//==== Projecting relationship properties

==== Handling parallel relationships

Neo4j supports parallel relationships, i.e., multiple relationships between two nodes.
By default, GDS preserves the parallel relationships.
We can specify how parallel relationships should be merged into a single relationship via the `aggregation` parameter in a relationship projection.

// aggregating properties


// special case: COUNT example
[role=query-example, group=count-aggregate]
--
.The following projects a `readSums` graph containing the `Person` and `Book` nodes and aggregated `READ` relationships:
[source, cypher, role=noplay]
----
CALL gds.graph.create('readSums', ['Person', 'Book'], {READ: {properties: {numberOfReads: {property:'*', aggregation: 'COUNT'}}}})
YIELD
  graphName AS graph, relationshipProjection AS readProjection, nodeCount AS nodes, relationshipCount AS rels
----

.Results
[opts="header", cols="1,3m,1m,1m"]
|===
| graph      | readProjection                                                                  | nodes  | rels
| "readSums" | {READ={orientation=NATURAL, aggregation=DEFAULT, type=READ, properties={numberOfReads={defaultValue=null, property=*, aggregation=COUNT}}}} | 5      | 3
|===
--

Next, we will verify that the `READ` relationships were correctly aggregated.

[role=query-example, group=count-aggregate]
--
.The following query streams the relationship property `numberOfReads`:
[source, cypher, role=noplay]
----
CALL gds.graph.streamRelationshipProperty('readSums', 'numberOfReads')
YIELD sourceNodeId, targetNodeId, propertyValue AS numberOfReads
RETURN gds.util.asNode(sourceNodeId).name AS src, gds.util.asNode(targetNodeId).name AS trg, numberOfReads
ORDER BY numberOfReads DESC, src
----

.Results
[opts="header", cols="1,1,1"]
|===
| src         | trg                  | numberOfReads
| "Florentin" |  "The Hobbit"        | 2.0
| "Adam"      |  "The Hobbit"        | 1.0
| "Veselin"   |  "Frankenstein"      | 1.0
|===
--

We can see, that the two READ relationships between Florentin and the Hobbit result in `2` numberOfReads.

// 4. Star projection !?


== Cypher Projection

The more flexible, expressive approach with lesser focus on performance.
Recommended to be primarily used during the development phase.

[[graph-create-cypher-syntax]]
=== Syntax

A Cypher projection takes three mandatory arguments: `graphName`, `nodeQuery` and `relationshipQuery`.
In addition, the optional `configuration` parameter allows us to further configure graph creation.

[source, cypher, role=noplay]
----
CALL gds.graph.create.cypher(
    graphName: String,
    nodeQuery: String,
    relationshipQuery: String,
    configuration: Map
)
----

.Parameters
[opts="header",cols="1,1,1"]
|===
| Name              | Optional | Description
| graphName         | no       | The name under which the graph is stored in the catalog.
| nodeQuery         | no       | Cypher query to project nodes.
| relationshipQuery | no       | Cypher query to project relationships.
| configuration     | yes      | Additional parameters to configure the Cypher projection.
|===

.Configuration
[opts="header",cols="1,1,1,4"]
|===
| Name                   | Type    | Default        | Description
| readConcurrency        | Integer | 4              | The number of concurrent threads used for creating the graph.
| validateRelationships  | Boolean | true           | Whether to throw an error if relationships contain nodes not included in the nodeQuery.
| parameters             | Map     | empty map      | A map of user-defined query parameters that are passed into the node and relationship query.
|===

// TODO put this into a life-cycle subsection
[NOTE]
--
The projected graphs will reside in the catalog until:

- the graph is dropped using <<catalog-graph-drop, gds.graph.drop>>
- the Neo4j database from which to graph was projected is stopped or dropped
- the Neo4j database management system is stopped.
--

NOTE: To get information about a stored named graph, including its schema, one can use <<catalog-graph-list, gds.graph.list>>.


[[graph-create-cypher-examples]]
=== Examples

We can also use Cypher to select the nodes and relationships to be projected into the in-memory graph.

.Create a graph using a Cypher projection:
[source, cypher, role=noplay]
----
CALL gds.graph.create.cypher(
    'my-cypher-graph',
    'MATCH (n:Person) RETURN id(n) AS id',
    'MATCH (a:Person)-[:LIKES]->(b:Person) RETURN id(a) AS source, id(b) AS target'
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----


== Using projected graphs

After creating the graphs in the catalog, we can refer to them in algorithms by using their name.

.Run Page Rank on one of our created graphs:
[source, cypher, role=noplay]
----
CALL gds.pageRank.stream('my-native-graph') YIELD nodeId, score;
----
