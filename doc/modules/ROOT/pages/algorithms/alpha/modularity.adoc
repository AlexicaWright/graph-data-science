[[alpha-algorithms-modularity]]
[.alpha]
= Modularity metric
:description: This section describes the Modularity metric algorithm in the Neo4j Graph Data Science library.
:entity: node
:result: modularity
:algorithm: Modularity Metric

include::partial$/operations-reference/alpha-note.adoc[]

:directed:
:undirected:
:homogeneous:
:weighted:
include::partial$/algorithms/shared/algorithm-traits.adoc[]


== Introduction



== Syntax

include::partial$/algorithms/shared/syntax-intro-named-graph.adoc[]

.Modularity syntax per mode
[.tabbed-example]
====


[.include-with-stream]
======
.Run Modularity in stream mode on a named graph.
[source, cypher, role=noplay]
----
CALL gds.alpha.modularity.stream(
  graphName: String,
  configuration: Map
) YIELD
  communityId: Integer,
  modularity: Float
----

include::partial$/algorithms/common-configuration/common-parameters.adoc[]

.Configuration
[opts="header",cols="3,2,3m,2,8"]
|===
| Name          | Type   | Default | Optional | Description
include::partial$/algorithms/common-configuration/common-stream-stats-configuration-entries.adoc[]
include::partial$/algorithms/alpha/modularity/specific-configuration.adoc[]
|===

.Results
[opts="header"]
|===
| Name        | Type    | Description
| communityId   | Integer | Community ID.
| modularity | Float   | Modularity of the community.
|===
======

====


== Examples

:algorithm-name: Modularity
:graph-description: social network
:image-file: two-user-communities.svg
include::partial$/algorithms/shared/examples-intro.adoc[]

.The following Cypher statement will create the example graph in the Neo4j database:
[source, cypher, role=noplay setup-query]
----
CREATE
  (nAlice:User {name: 'Alice', seed: 42}),
  (nBridget:User {name: 'Bridget', seed: 42}),
  (nCharles:User {name: 'Charles', seed: 42}),
  (nDoug:User {name: 'Doug'}),
  (nMark:User {name: 'Mark'}),
  (nMichael:User {name: 'Michael'}),

  (nAlice)-[:LINK {weight: 1}]->(nBridget),
  (nAlice)-[:LINK {weight: 1}]->(nCharles),
  (nCharles)-[:LINK {weight: 1}]->(nBridget),

  (nAlice)-[:LINK {weight: 5}]->(nDoug),

  (nMark)-[:LINK {weight: 1}]->(nDoug),
  (nMark)-[:LINK {weight: 1}]->(nMichael),
  (nMichael)-[:LINK {weight: 1}]->(nMark);
----

This graph has two clusters of _Users_, that are closely connected.
Between those clusters there is one single edge.
The relationships that connect the nodes in each component have a property `weight` which determines the strength of the relationship.

We can now project the graph and store it in the graph catalog.
We load the `LINK` relationships with orientation set to `UNDIRECTED` as this works best with the Louvain algorithm which we will use to create the communities that we evaluate using Modularity.

include::partial$/algorithms/shared/examples-named-native-note.adoc[]

.The following statement will project the graph and store it in the graph catalog.
[source, cypher, role=noplay graph-project-query]
----
CALL gds.graph.project(
    'myGraph',
    'User',
    {
        LINK: {
            orientation: 'UNDIRECTED'
        }
    },
    {
        nodeProperties: 'seed',
        relationshipProperties: 'weight'
    }
)
----

We now run the xref:algorithms/louvain.adoc[Louvain algorithm] to create a division of the nodes into communities that we can then evalutate.

[role=query-example, group=louvain-modularity]
--
.The following will run the Louvain algorithm and store the results in `myGraph`:
[source, cypher, role=noplay]
----
CALL gds.louvain.mutate('myGraph', { mutateProperty: 'community', relationshipWeightProperty: 'weight' })
YIELD communityCount
----

.Results
[opts="header"]
|===
| communityCount
| 3
|===
--

Now our in-memory graph `myGraph` is populated with node properties under the key `community` that we can set as input for our evaluation using Modularity.
The nodes are now assigned to communities in the following way:

.Community assignments
[opts="header"]
|===
| name      | community
| "Alice"   | 3
| "Bridget" | 2
| "Charles" | 2
| "Doug"    | 3
| "Mark"    | 5
| "Michael" | 5
|===

Please see the xref:graph-catalog-node-ops.adoc#catalog-graph-stream-single-node-property-example[stream node properties] procedure for how to obtain such an assignment table.

For more information about Louvain, see its xref:algorithms/louvain.adoc[algorithm page].


=== Stream

Since we now have a community detection, we can evaluate how good it is under the modularity metric.
Note that we in this case we use the feature of relationships being weighted by a relationship property.

The Modularity stream procedure returns the modularity for each community.
This allows us to inspect the results directly or post-process them in Cypher without any side effects.

For more details on the stream mode in general, see xref:common-usage/running-algos.adoc#running-algos-stream[Stream].

[role=query-example, group=louvain-modularity]
--
.The following will run the Modularity algorithm in `stream` mode:
[source, cypher, role=noplay]
----
CALL gds.alpha.modularity.stream('myGraph', { communityProperty: 'community', relationshipWeightProperty: 'weight' })
YIELD communityId, modularity
----

.Results
[opts="header"]
|===
| communityId | modularity
| 2           | 0.057851239669421
| 3           | 0.105371900826446
| 5           | 0.130165289256198
|===
--
