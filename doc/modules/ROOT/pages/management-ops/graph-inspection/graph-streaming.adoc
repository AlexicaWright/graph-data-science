= Streaming the graph

To inspect the graph you can use the following procedures to stream parts of the graph through Cypher.

== Nodes

To inspect stored values, the `gds.graph.nodeProperties.stream` procedure can be used.
This is useful if we ran multiple algorithms in `mutate` mode and want to retrieve some or all of the results.

=== Syntax

.Syntax descriptions of the different streaming options over nodes
[.tabbed-example, caption=]
====
[.include-with-stream-single-property]
======
[source, cypher, role=noplay]
----
CALL gds.graph.nodeProperty.stream(
    graphName: String,
    nodeProperties: String,
    nodeLabels: String or List of Strings,
    configuration: Map
)
YIELD
    nodeId: Integer,
    propertyValue: Integer or Float or List of Integer or List of Float
----

.Parameters
[opts="header",cols="1,3,1,5"]
|===
| Name           | Type                       | Optional | Description
| graphName      | String                     | no       | The name under which the graph is stored in the catalog.
| nodeProperties | String                     | no       | The node property in the graph to stream.
| nodeLabels     | String or List of Strings  | yes      | The node labels to stream the node properties for graph.
| configuration  | Map                        | yes      | Additional parameters to configure streamNodeProperties.
|===

.Configuration
[opts="header",cols="1,1,1,7"]
|===
| Name                   | Type                  | Default | Description
| concurrency            | Integer               | 4       | The number of concurrent threads. Note, this procedure is always running single-threaded.
|===

.Results
[opts="header",cols="2,3,5"]
|===
| Name            | Type                                                 | Description
|nodeId           | Integer                                              | The id of the node.
.^|propertyValue    a|
* Integer
* Float
* List of Integer
* List of Float  .^| The stored property value.
|===
======

[.include-with-stream]
======
[source, cypher, role=noplay]
----
CALL gds.graph.nodeProperties.stream(
    graphName: String,
    nodeProperties: String or List of Strings,
    nodeLabels: String or List of Strings,
    configuration: Map
)
YIELD
    nodeId: Integer,
    nodeProperty: String,
    propertyValue: Integer or Float or List of Integer or List of Float
----

.Parameters
[opts="header",cols="1,3,1,5"]
|===
| Name           | Type                       | Optional | Description
| graphName      | String                     | no       | The name under which the graph is stored in the catalog.
| nodeProperties | String or List of Strings  | no       | The node properties in the graph to stream.
| nodeLabels     | String or List of Strings  | yes      | The node labels to stream the node properties for graph.
| configuration  | Map                        | yes      | Additional parameters to configure streamNodeProperties.
|===

.Configuration
[opts="header",cols="1,1,1,7"]
|===
| Name                   | Type                  | Default | Description
| concurrency            | Integer               | 4       | The number of concurrent threads. Note, this procedure is always running single-threaded.
|===

.Results
[opts="header",cols="2,3,5"]
|===
| Name            | Type                                                 | Description
|nodeId           | Integer                                              | The id of the node.
|nodeProperty     | String                                               | The name of the node property.
.^|propertyValue    a|
* Integer
* Float
* List of Integer
* List of Float  .^| The stored property value.
|===
======
====

[[streaming-nodes-examples]]
=== Examples

In order to demonstrate the GDS capabilities of streaming node properties, we are going to create a small social network graph in Neo4j and project it into our graph catalog.

.The following Cypher statement will create the example graph in the Neo4j database:
[source, cypher, role=noplay setup-query, group=nodes]
----
CREATE
  (florentin:Person { name: 'Florentin', age: 16 }),
  (adam:Person { name: 'Adam', age: 18 }),
  (veselin:Person { name: 'Veselin', age: 20 }),
  (hobbit:Book { name: 'The Hobbit', numberOfPages: 310 }),
  (florentin)-[:KNOWS { since: 2010 }]->(adam),
  (florentin)-[:KNOWS { since: 2018 }]->(veselin),
  (adam)-[:READ]->(hobbit)
----

.Project the small social network graph:
[source, cypher, role=noplay graph-project-query, group=nodes]
----
CALL gds.graph.project(
  'socialGraph',
  {
    Person: {properties: "age"},
    Book: {}
  },
  ['KNOWS', 'READ']
)
----

.Compute the Degree Centrality in our social graph:
[source, cypher, role=noplay graph-project-query, group=nodes]
----
CALL gds.degree.mutate('socialGraph', {mutateProperty: 'score'})
----

We can stream node properties stored in a named in-memory graph back to the user.
This is useful if we ran multiple algorithms in `mutate` mode and want to retrieve some or all of the results.
This is similar to what an algorithm `stream` execution mode does, but allows more fine-grained control over the operations.



[[catalog-graph-stream-single-node-property-example]]
==== Single property

In the following, we stream the previously computed scores `score`.

[role=query-example, group=nodes]
--
.Stream the `score` node property:
[source, cypher, role=noplay]
----
CALL gds.graph.nodeProperty.stream('socialGraph', 'score')
YIELD nodeId, propertyValue
RETURN gds.util.asNode(nodeId).name AS name, propertyValue AS score
ORDER BY score DESC
----

.Results
[opts="header"]
|===
| name         | score
| "Florentin"  | 2.0
| "Adam"       | 1.0
| "Veselin"    | 0.0
| "The Hobbit" | 0.0
|===
--

NOTE: The above example requires all given properties to be present on at least one node projection, and the properties will be streamed for all such projections.

[[catalog-graph-stream-node-labels-example]]
==== NodeLabels

The procedure can be configured to stream just the properties for specific node labels.

[role=query-example, group=nodes]
--
.Stream the `score` property for `Person` nodes:
[source, cypher, role=noplay]
----
CALL gds.graph.nodeProperty.stream('socialGraph', 'score', ['Person'])
YIELD nodeId, propertyValue
RETURN gds.util.asNode(nodeId).name AS name, propertyValue AS score
ORDER BY score DESC
----

.Results
[opts="header"]
|===
| name        | score
| "Florentin" | 2.0
| "Adam"      | 1.0
| "Veselin"   | 0.0
|===
--

It is required, that all specified node labels have the node property.

[[catalog-graph-stream-node-properties-example]]
==== Multiple Properties

We can also stream several properties at once.

[role=query-example, group=nodes]
--
.Stream multiple node properties:
[source, cypher, role=noplay]
----
CALL gds.graph.nodeProperties.stream('socialGraph', ['score', 'age'])
YIELD nodeId, nodeProperty, propertyValue
RETURN gds.util.asNode(nodeId).name AS name, nodeProperty, propertyValue
ORDER BY name, nodeProperty
----

.Results
[opts="header"]
|===
| name         | nodeProperty  | propertyValue
| "Adam"       | "age"         | 18
| "Adam"       | "score"       | 1.0
| "Florentin"  | "age"         | 16
| "Florentin"  | "score"       | 2.0
| "Veselin"    | "age"         | 20
| "Veselin"    | "score"       | 0.0
|===
--

[NOTE]
====
When streaming multiple node properties, the name of each property is included in the result.
This adds with some overhead, as each property name must be repeated for each node in the result, but is necessary in order to distinguish properties.
====


== Relationships

To inspect the relationship topology only, the `gds.beta.graph.relationships.stream` procedure can be used.
To inspect stored relationship property values, the `streamRelationshipProperties` procedure can be used.
This is useful if we ran multiple algorithms in `mutate` mode and want to retrieve some or all of the results.

=== Syntax

.Syntax descriptions of the different streaming options over relationships
[.tabbed-example, caption=]
====

[.include-with-stream-topology]
======
[source, cypher, role=noplay]
----
CALL gds.beta.graph.relationships.stream(
    graphName: String,
    relationshipTypes: List of Strings,
    configuration: Map
)
YIELD
    sourceNodeId: Integer,
    targetNodeId: Integer,
    relationshipType: String
----

.Parameters
[opts="header",cols="1,3,1,5"]
|===
| Name                   | Type                       | Optional | Description
| graphName              | String                     | no       | The name under which the graph is stored in the catalog.
| relationshipTypes      | List of Strings            | yes      | The relationship types to stream the relationship properties for graph.
| configuration          | Map                        | yes      | Additional parameters to configure streamNodeProperties.
|===

.Configuration
[opts="header",cols="1,1,1,7"]
|===
| Name                   | Type                  | Default | Description
| concurrency            | Integer               | 4       | The number of concurrent threads. Note, this procedure is always running single-threaded.
|===

.Results
[opts="header",cols="2,3,5"]
|===
| Name                  | Type                                                 | Description
| sourceNodeId          | Integer                                              | The id of the source node for the relationship.
| targetNodeId          | Integer                                              | The id of the target node for the relationship.
| relationshipType      | Integer                                              | The type of the relationship.
|===
======

[.include-with-stream-single-property]
======
[source, cypher, role=noplay]
----
CALL gds.graph.relationshipProperty.stream(
    graphName: String,
    relationshipProperty: String,
    relationshipTypes: List of Strings,
    configuration: Map
)
YIELD
    sourceNodeId: Integer,
    targetNodeId: Integer,
    relationshipType: String,
    propertyValue: Integer or Float
----

.Parameters
[opts="header",cols="1,3,1,5"]
|===
| Name                   | Type                       | Optional | Description
| graphName              | String                     | no       | The name under which the graph is stored in the catalog.
| relationshipProperty   | String                     | no       | The relationship property in the graph to stream.
| relationshipTypes      | List of Strings            | yes      | The relationship types to stream the relationship properties for graph.
| configuration          | Map                        | yes      | Additional parameters to configure streamNodeProperties.
|===

.Configuration
[opts="header",cols="1,1,1,7"]
|===
| Name                   | Type                  | Default | Description
| concurrency            | Integer               | 4       | The number of concurrent threads. Note, this procedure is always running single-threaded.
|===

.Results
[opts="header",cols="2,3,5"]
|===
| Name                  | Type                                                 | Description
| sourceNodeId          | Integer                                              | The id of the source node for the relationship.
| targetNodeId          | Integer                                              | The id of the target node for the relationship.
| relationshipType      | Integer                                              | The type of the relationship.
.^| propertyValue
a|
* Integer
* Float
.^| The stored property value.
|===
======

[.include-with-stream-multiple-properties]
======
[source, cypher, role=noplay]
----
CALL gds.graph.relationshipProperties.stream(
    graphName: String,
    relationshipProperties: List of String,
    relationshipTypes: List of Strings,
    configuration: Map
)
YIELD
    sourceNodeId: Integer,
    targetNodeId: Integer,
    relationshipType: String,
    relationshipProperty: String,
    propertyValue: Integer or Float
----

.Parameters
[opts="header",cols="1,3,1,5"]
|===
| Name                   | Type                       | Optional | Description
| graphName              | String                     | no       | The name under which the graph is stored in the catalog.
| relationshipProperties | List of String             | no       | The relationship properties in the graph to stream.
| relationshipTypes      | List of Strings            | yes      | The relationship types to stream the relationship properties for graph.
| configuration          | Map                        | yes      | Additional parameters to configure streamNodeProperties.
|===

.Configuration
[opts="header",cols="1,1,1,7"]
|===
| Name                   | Type                  | Default | Description
| concurrency            | Integer               | 4       | The number of concurrent threads. Note, this procedure is always running single-threaded.
|===

.Results
[opts="header",cols="2,3,5"]
|===
| Name                  | Type                                                 | Description
| sourceNodeId          | Integer                                              | The id of the source node for the relationship.
| targetNodeId          | Integer                                              | The id of the target node for the relationship.
| relationshipType      | Integer                                              | The type of the relationship.
| relationshipProperty  | Integer                                              | The name of the relationship property.
.^| propertyValue
a|
* Integer
* Float
.^| The stored property value.
|===
======
====


=== Examples

In order to demonstrate the GDS capabilities over node properties, we are going to create a small graph in Neo4j and project it into our graph catalog.

image::example-graphs/node-similarity.svg[Visualization of the example graph,align="center"]

.The following Cypher statement will create the example graph in the Neo4j database:
[source, cypher, role=noplay setup-query, group=rels]
----
CREATE
  (alice:Person {name: 'Alice'}),
  (bob:Person {name: 'Bob'}),
  (carol:Person {name: 'Carol'}),
  (dave:Person {name: 'Dave'}),
  (eve:Person {name: 'Eve'}),
  (guitar:Instrument {name: 'Guitar'}),
  (synth:Instrument {name: 'Synthesizer'}),
  (bongos:Instrument {name: 'Bongos'}),
  (trumpet:Instrument {name: 'Trumpet'}),

  (alice)-[:LIKES { score: 5 }]->(guitar),
  (alice)-[:LIKES { score: 4 }]->(synth),
  (alice)-[:LIKES { score: 3, strength: 0.5}]->(bongos),
  (bob)-[:LIKES { score: 4 }]->(guitar),
  (bob)-[:LIKES { score: 5 }]->(synth),
  (carol)-[:LIKES { score: 2 }]->(bongos),
  (dave)-[:LIKES { score: 3 }]->(guitar),
  (dave)-[:LIKES { score: 1 }]->(synth),
  (dave)-[:LIKES { score: 5 }]->(bongos)
----

.Project the graph:
[source, cypher, role=noplay graph-project-query, group=rels]
----
CALL gds.graph.project(
  'personsAndInstruments',
  ['Person', 'Instrument'],         // <1>
  {
    LIKES: {
      type: 'LIKES',                // <2>
      properties: {
        strength: {                 // <3>
          property: 'strength',
          defaultValue: 1.0
        },
        score: {
          property: 'score'         // <4>
        }
      }
    }
  }
)
----
<1> Project node labels `Person` and `Instrument`.
<2> Project relationship type `LIKES`.
<3> Project property `strength` of relationship type `LIKES` setting a default value of `1.0` because not all relationships have that property.
<4> Project property `score` of relationship type `LIKES`.

.Compute the Node Similarity in our graph:
[source, cypher, role=noplay graph-project-query]
----
CALL gds.nodeSimilarity.mutate('personsAndInstruments', {   // <1>
  mutateRelationshipType: 'SIMILAR',                        // <2>
  mutateProperty: 'score'                                   // <3>
})
----
<1> Run NodeSimilarity in `mutate` mode on `personsAndInstruments` projected graph.
<2> The algorithm will add relationships of type `SIMILAR` to the projected graph.
<3> The algorithm will add relationship property `score` for each added relationship.


[[catalog-graph-stream-relationship-topology-example]]
==== Topology

The most basic case for streaming relationship information from a named graph is streaming its topology.
In this example below we stream relationship topology for all relationship types, represented by source, target and relationship type.

[role=query-example, group=rels]
--
.Stream all relationships:
[source, cypher, role=noplay ]
----
CALL gds.beta.graph.relationships.stream(
  'personsAndInstruments'                  // <1>
)
YIELD
  sourceNodeId, targetNodeId, relationshipType
RETURN
  gds.util.asNode(sourceNodeId).name as source, gds.util.asNode(targetNodeId).name as target, relationshipType
ORDER BY source ASC, target ASC
----
<1> The name of the projected graph.

.Results
[opts="header"]
|===
| source  | target        | relationshipType
| "Alice" | "Bob"         | "SIMILAR"
| "Alice" | "Bongos"      | "LIKES"
| "Alice" | "Carol"       | "SIMILAR"
| "Alice" | "Dave"        | "SIMILAR"
| "Alice" | "Guitar"      | "LIKES"
| "Alice" | "Synthesizer" | "LIKES"
| "Bob"   | "Alice"       | "SIMILAR"
| "Bob"   | "Dave"        | "SIMILAR"
| "Bob"   | "Guitar"      | "LIKES"
| "Bob"   | "Synthesizer" | "LIKES"
| "Carol" | "Alice"       | "SIMILAR"
| "Carol" | "Bongos"      | "LIKES"
| "Carol" | "Dave"        | "SIMILAR"
| "Dave"  | "Alice"       | "SIMILAR"
| "Dave"  | "Bob"         | "SIMILAR"
| "Dave"  | "Bongos"      | "LIKES"
| "Dave"  | "Carol"       | "SIMILAR"
| "Dave"  | "Guitar"      | "LIKES"
| "Dave"  | "Synthesizer" | "LIKES"
|===
--

As we can see from the results, we get two relationship types (`SIMILAR` and `LIKES`).
We can further on filter the relationship types we want to stream.
This can be achieved by passing a second argument to the procedure as demonstrated in the next example.

[role=query-example, group=rels]
--
.Stream a single relationship for specific relationship type:
[source, cypher, role=noplay]
----
CALL gds.beta.graph.relationships.stream(
  'personsAndInstruments',                  // <1>
  ['SIMILAR']                               // <2>
)
YIELD
  sourceNodeId, targetNodeId, relationshipType
RETURN
  gds.util.asNode(sourceNodeId).name as source, gds.util.asNode(targetNodeId).name as target, relationshipType
ORDER BY source ASC, target ASC
----
<1> The name of the projected graph.
<2> List of relationship types we want to stream from, only use the ones we need.

.Results
[opts="header"]
|===
|  source | target  | relationshipType
| "Alice" | "Bob"   | "SIMILAR"
| "Alice" | "Carol" | "SIMILAR"
| "Alice" | "Dave"  | "SIMILAR"
| "Bob"   | "Alice" | "SIMILAR"
| "Bob"   | "Dave"  | "SIMILAR"
| "Carol" | "Alice" | "SIMILAR"
| "Carol" | "Dave"  | "SIMILAR"
| "Dave"  | "Alice" | "SIMILAR"
| "Dave"  | "Bob"   | "SIMILAR"
| "Dave"  | "Carol" | "SIMILAR"
|===
--


[[catalog-graph-stream-single-relationship-property-example]]
==== Single property

The most basic case for streaming relationship properties from a named graph is a single property.
In the example below we stream the relationship property `score`.

[role=query-example, group=rels]
--
.Stream a single relationship property:
[source, cypher, role=noplay]
----
CALL gds.graph.relationshipProperty.stream(
  'personsAndInstruments',                  // <1>
  'score'                                   // <2>
)
YIELD
  sourceNodeId, targetNodeId, relationshipType, propertyValue
RETURN
  gds.util.asNode(sourceNodeId).name as source, gds.util.asNode(targetNodeId).name as target, relationshipType, propertyValue
ORDER BY source ASC, target ASC
----
<1> The name of the projected graph.
<2> The property we want to stream out.

.Results
[opts="header"]
|===
| source  | target        | relationshipType  | propertyValue
| "Alice" | "Bob"         | "SIMILAR"         | 0.6666666666666666
| "Alice" | "Bongos"      | "LIKES"           | 3.0
| "Alice" | "Carol"       | "SIMILAR"         | 0.3333333333333333
| "Alice" | "Dave"        | "SIMILAR"         | 1.0
| "Alice" | "Guitar"      | "LIKES"           | 5.0
| "Alice" | "Synthesizer" | "LIKES"           | 4.0
| "Bob"   | "Alice"       | "SIMILAR"         | 0.6666666666666666
| "Bob"   | "Dave"        | "SIMILAR"         | 0.6666666666666666
| "Bob"   | "Guitar"      | "LIKES"           | 4.0
| "Bob"   | "Synthesizer" | "LIKES"           | 5.0
| "Carol" | "Alice"       | "SIMILAR"         | 0.3333333333333333
| "Carol" | "Bongos"      | "LIKES"           | 2.0
| "Carol" | "Dave"        | "SIMILAR"         | 0.3333333333333333
| "Dave"  | "Alice"       | "SIMILAR"         | 1.0
| "Dave"  | "Bob"         | "SIMILAR"         | 0.6666666666666666
| "Dave"  | "Bongos"      | "LIKES"           | 5.0
| "Dave"  | "Carol"       | "SIMILAR"         | 0.3333333333333333
| "Dave"  | "Guitar"      | "LIKES"           | 3.0
| "Dave"  | "Synthesizer" | "LIKES"           | 1.0
|===
--

As we can see from the results, we get two relationship types (`SIMILAR` and `LIKES`) that have the `score` relationship property.
We can further on filter the relationship types we want to stream, this is demonstrated in the next example.

[role=query-example]
--
.Stream a single relationship property for specific relationship type:
[source, cypher, role=noplay, group=rels]
----
CALL gds.graph.relationshipProperty.stream(
  'personsAndInstruments',                  // <1>
  'score',                                  // <2>
  ['SIMILAR']                               // <3>
)
YIELD
  sourceNodeId, targetNodeId, relationshipType, propertyValue
RETURN
  gds.util.asNode(sourceNodeId).name as source, gds.util.asNode(targetNodeId).name as target, relationshipType, propertyValue
ORDER BY source ASC, target ASC
----
<1> The name of the projected graph.
<2> The property we want to stream out.
<3> List of relationship types we want to stream the property from, only use the ones we need.

.Results
[opts="header"]
|===
|  source | target  | relationshipType  | propertyValue
| "Alice" | "Bob"   | "SIMILAR"         | 0.6666666666666666
| "Alice" | "Carol" | "SIMILAR"         | 0.3333333333333333
| "Alice" | "Dave"  | "SIMILAR"         | 1.0
| "Bob"   | "Alice" | "SIMILAR"         | 0.6666666666666666
| "Bob"   | "Dave"  | "SIMILAR"         | 0.6666666666666666
| "Carol" | "Alice" | "SIMILAR"         | 0.3333333333333333
| "Carol" | "Dave"  | "SIMILAR"         | 0.3333333333333333
| "Dave"  | "Alice" | "SIMILAR"         | 1.0
| "Dave"  | "Bob"   | "SIMILAR"         | 0.6666666666666666
| "Dave"  | "Carol" | "SIMILAR"         | 0.3333333333333333
|===
--

[[catalog-graph-stream-relationship-properties-example]]
==== Multiple properties

It is also possible to stream multiple relationship properties.

[role=query-example, group=rels]
--
.Stream multiple relationship properties:
[source, cypher, role=noplay]
----
CALL gds.graph.relationshipProperties.stream(
  'personsAndInstruments',                      // <1>
  ['score', 'strength'],                        // <2>
  ['LIKES']                                     // <3>
)
YIELD
  sourceNodeId, targetNodeId, relationshipType, relationshipProperty, propertyValue
RETURN
  gds.util.asNode(sourceNodeId).name as source, gds.util.asNode(targetNodeId).name as target, relationshipType, relationshipProperty, propertyValue
ORDER BY source ASC, target ASC
----
<1> The name of the projected graph.
<2> List of properties we want to stream out, allows us to stream more than one property.
<3> List of relationship types we want to stream the property from, only use the ones we need.

.Results
[opts="header"]
|===
| source  | target        | relationshipType  | relationshipProperty  | propertyValue
| "Alice" | "Bongos"      | "LIKES"           | "score"               | 3.0
| "Alice" | "Bongos"      | "LIKES"           | "strength"            | 0.5
| "Alice" | "Guitar"      | "LIKES"           | "score"               | 5.0
| "Alice" | "Guitar"      | "LIKES"           | "strength"            | 1.0
| "Alice" | "Synthesizer" | "LIKES"           | "score"               | 4.0
| "Alice" | "Synthesizer" | "LIKES"           | "strength"            | 1.0
| "Bob"   | "Guitar"      | "LIKES"           | "score"               | 4.0
| "Bob"   | "Guitar"      | "LIKES"           | "strength"            | 1.0
| "Bob"   | "Synthesizer" | "LIKES"           | "score"               | 5.0
| "Bob"   | "Synthesizer" | "LIKES"           | "strength"            | 1.0
| "Carol" | "Bongos"      | "LIKES"           | "score"               | 2.0
| "Carol" | "Bongos"      | "LIKES"           | "strength"            | 1.0
| "Dave"  | "Bongos"      | "LIKES"           | "score"               | 5.0
| "Dave"  | "Bongos"      | "LIKES"           | "strength"            | 1.0
| "Dave"  | "Guitar"      | "LIKES"           | "score"               | 3.0
| "Dave"  | "Guitar"      | "LIKES"           | "strength"            | 1.0
| "Dave"  | "Synthesizer" | "LIKES"           | "score"               | 1.0
| "Dave"  | "Synthesizer" | "LIKES"           | "strength"            | 1.0
|===
--


==== Multiple relationship types

Similar to the multiple relationship properties we can stream properties for multiple relationship types.

[role=query-example, group=rels]
--
.Stream relationship properties of a multiple relationship projections:
[source, cypher, role=noplay]
----
CALL gds.graph.relationshipProperties.stream(
  'personsAndInstruments',                          // <1>
  ['score'],                                        // <2>
  ['LIKES', 'SIMILAR']                              // <3>
)
YIELD
  sourceNodeId, targetNodeId, relationshipType, relationshipProperty, propertyValue
RETURN
  gds.util.asNode(sourceNodeId).name as source,     // <4>
  gds.util.asNode(targetNodeId).name as target,     // <5>
  relationshipType,
  relationshipProperty,
  propertyValue
ORDER BY source ASC, target ASC
----
<1> The name of the projected graph.
<2> List of properties we want to stream out, allows us to stream more than one property.
<3> List of relationship types we want to stream the property from, only use the ones we need.
<4> Return the `name` of the source node.
<5> Return the `name` of the target node.

.Results
[opts="header"]
|===
| source  | target        | relationshipType  | relationshipProperty  | propertyValue
| "Alice" | "Bob"         | "SIMILAR"         | "score"               | 0.6666666666666666
| "Alice" | "Bongos"      | "LIKES"           | "score"               | 3.0
| "Alice" | "Carol"       | "SIMILAR"         | "score"               | 0.3333333333333333
| "Alice" | "Dave"        | "SIMILAR"         | "score"               | 1.0
| "Alice" | "Guitar"      | "LIKES"           | "score"               | 5.0
| "Alice" | "Synthesizer" | "LIKES"           | "score"               | 4.0
| "Bob"   | "Alice"       | "SIMILAR"         | "score"               | 0.6666666666666666
| "Bob"   | "Dave"        | "SIMILAR"         | "score"               | 0.6666666666666666
| "Bob"   | "Guitar"      | "LIKES"           | "score"               | 4.0
| "Bob"   | "Synthesizer" | "LIKES"           | "score"               | 5.0
| "Carol" | "Alice"       | "SIMILAR"         | "score"               | 0.3333333333333333
| "Carol" | "Bongos"      | "LIKES"           | "score"               | 2.0
| "Carol" | "Dave"        | "SIMILAR"         | "score"               | 0.3333333333333333
| "Dave"  | "Alice"       | "SIMILAR"         | "score"               | 1.0
| "Dave"  | "Bob"         | "SIMILAR"         | "score"               | 0.6666666666666666
| "Dave"  | "Bongos"      | "LIKES"           | "score"               | 5.0
| "Dave"  | "Carol"       | "SIMILAR"         | "score"               | 0.3333333333333333
| "Dave"  | "Guitar"      | "LIKES"           | "score"               | 3.0
| "Dave"  | "Synthesizer" | "LIKES"           | "score"               | 1.0
|===
--

NOTE: The properties we want to stream must exist for each specified relationship type.

// FIXME is this the right place? (streaming seems like the best place)
[[utility-functions-catalog]]
== Utility functions

Utility functions allow accessing specific nodes of in-memory graphs directly from a Cypher query.

.Catalog Functions
[opts=header,cols="1m,1"]
|===
| Name                  | Description
| gds.util.nodeProperty | Allows accessing a node property stored in a named graph.
|===


=== Syntax

[opts=header,cols="1m,1"]
|===
| Name                                                                                               | Description
| gds.util.nodeProperty(graphName: STRING, nodeId: INTEGER, propertyKey: STRING, nodeLabel: STRING?) | Named graph in the catalog, Neo4j node id, node property key and optional node label present in the named-graph.
|===

If a node label is given, the property value for the corresponding projection and the given node is returned.
If no label or `'*'` is given, the property value is retrieved and returned from an arbitrary projection that contains the given propertyKey.
If the property value is missing for the given node, `null` is returned.


=== Examples

We use the `socialGraph` with the property `score` introduced xref:management-ops/graph-inspection/graph-streaming.adoc#streaming-nodes-examples[above].

[role=query-example, group=nodes]
--
.Access a property node property for Florentin:
[source, cypher, role=noplay]
----
MATCH (florentin:Person {name: 'Florentin'})
RETURN
  florentin.name AS name,
  gds.util.nodeProperty('socialGraph', id(florentin), 'score') AS score
----

.Results
[opts="header",cols="2"]
|===
| name        | score
| "Florentin" | 2.0
|===
--

We can also specifically return the `score` property from the `Person` projection in case other projections also have a `score` property as follows.

[role=query-example, group=nodes]
--
.Access a property node property from Person for Florentin:
[source, cypher, role=noplay]
----
MATCH (florentin:Person {name: 'Florentin'})
RETURN
  florentin.name AS name,
  gds.util.nodeProperty('socialGraph', id(florentin), 'score', 'Person') AS score
----

.Results
[opts="header",cols="2"]
|===
| name        | score
| "Florentin" | 2.0
|===
--
