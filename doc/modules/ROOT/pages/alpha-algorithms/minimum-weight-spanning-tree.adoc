[[alpha-algorithms-minimum-weight-spanning-tree]]
[.alpha]
= Minimum Weight Spanning Tree
:description: This section describes the Minimum Weight Spanning Tree algorithm in the Neo4j Graph Data Science library.
:entity: node
:result: spanning tree edge
:algorithm: Prim

include::partial$/operations-reference/alpha-note.adoc[]

:undirected:
:homogeneous:
:weighted:
include::partial$/algorithms/shared/algorithm-traits.adoc[]

== Introduction

The Minimum Weight Spanning Tree (MST) starts from a given node, finds all its reachable nodes and  returns the set of relationships that connect these nodes together with the minimum possible weight.
Prim's algorithm is one of the simplest and best-known minimum spanning tree algorithms.
It operates similarly to Dijkstra's shortest path algorithm, but instead of   minimizing the total length of a path ending at each relationship, it minimizes the length of each relationship individually.
Because of this, the algorithm can also work on graphs with negative weights.

For more information on this algorithm, see:

* https://en.wikipedia.org/wiki/Minimum_spanning_tree[Minimum Spanning Tree]


[[algorithms-minimum-weight-spanning-tree-usecase]]
=== Use cases

* Minimum spanning tree was applied to analyze airline and sea connections of Papua New Guinea, and minimize the travel cost of exploring the country.
 It was also used to help design low-cost tours that visit many destinations across the country. See  https://junctiv.com/wp-content/uploads/2020/07/2010-V12-1_Fitina_et_al_spanning_trees_for_travel_planning.pdf["An Application of Minimum Spanning Trees to Travel Planning"].
* Minimum spanning tree has been used to analyze and visualize correlations in a network of currencies, based on the correlation between currency returns.
  This is described in https://www.nbs.sk/_img/Documents/_PUBLIK_NBS_FSR/Biatec/Rok2013/07-2013/05_biatec13-7_resovsky_EN.pdf["Minimum Spanning Tree Application in the Currency Market"].
* Minimum spanning tree has also been shown to be a useful tool for tracing  transmission of infections  in outbreaks. See https://www.ncbi.nlm.nih.gov/pmc/articles/PMC516344/[Use of the Minimum Spanning Tree Model for Molecular Epidemiological Investigation of a Nosocomial Outbreak of Hepatitis C Virus Infection].


[[algorithms-minimum-weight-spanning-tree-limitations]]
=== Consideration

The MST algorithm gives meaningful results only if run on a graph where relationships have different weights.
If the graph has no weights (or all relationships have the same weight) then any spanning tree is also a minimum spanning tree.
 The algorithm implementation is executed using a single thread. Altering the concurrency configuration has no effect.

[[algorithms-minimum-weight-spanning-tree-syntax]]
== Syntax

include::partial$/algorithms/shared/syntax-intro-named-graph.adoc[]

.Spanning Tree syntax per mode
[.tabbed-example, caption = ]
====

[.include-with-stats]
======
.Run the algorithm in stats mode on a named graph.
[source, cypher, role=noplay]
----
CALL gds.alpha.spanningTree.stats(
  graphName: String,
  configuration: Map
)
YIELD
      effectiveNodeCount: Integer,
      totalWeight: Float,
      preProcessingMillis: Integer,
      computeMillis: Integer,
      configuration: Map
----
include::partial$/algorithms/common-configuration/common-parameters.adoc[]

.Configuration
[opts="header",cols="1,1,1,1,4"]
|===
| Name                                                                             | Type    | Default   | Optional  | Description
include::partial$/algorithms/common-configuration/common-stream-stats-configuration-entries.adoc[]
include::partial$/algorithms/alpha/spanning-tree/specific-configuration.adoc[]
|===

.Results
[opts="header",cols="1,1,6"]
|===
| Name                | Type    | Description
| effectiveNodeCount  | Integer | The number of visited nodes.
| totalWeight         | Float   | The sum of the weights of the relationships in the spanning tree.
| preProcessingMillis | Integer | Milliseconds for preprocessing the data.
| computeMillis       | Integer | Milliseconds for running the algorithm.
| configuration         | Map       | The configuration used for running the algorithm.
|===
======


[.include-with-write]
======
.Run the Spanning Tree algorithm in write mode on a named graph.
[source, cypher, role=noplay]
----
CALL gds.alpha.spanningTree.write(
  graphName: String,
  configuration: Map
)
YIELD
      effectiveNodeCount: Integer,
      totalWeight: Float,
      relationshipsWritten: Integer,
      preProcessingMillis: Integer,
      computeMillis: Integer,
      writeMillis: Integer,
      configuration: Map
----
include::partial$/algorithms/common-configuration/common-parameters.adoc[]

.Configuration
[opts="header",cols="1,1,1,1,4"]
|===
| Name                                                                             | Type    | Default   | Optional  | Description
| writeProperty                                                                    | String  | 'mst'     | yes       | The relationship type written back as result
| weightWriteProperty                                                              | String  | n/a       | no        | The weight property of the `writeProperty` relationship type written back
include::partial$/algorithms/common-configuration/common-write-configuration-entries.adoc[]
include::partial$/algorithms/alpha/spanning-tree/specific-configuration.adoc[]
|===

.Results
[opts="header",cols="1,1,6"]
|===
| Name                | Type    | Description
| effectiveNodeCount  | Integer | The number of visited nodes.
| totalWeight         | Float   | The sum of the weights of the relationships in the spanning tree.
| relationshipsWritten |Integer | The number of relationships written to the graph.
| preProcessingMillis | Integer | Milliseconds for preprocessing the data.
| computeMillis       | Integer | Milliseconds for running the algorithm.
| writeMillis         | Integer | Milliseconds for writing result data back.
| configuration         | Map       | The configuration used for running the algorithm.
|===
======

[.include-with-mutate]
======
.Run the Spanning Tree algorithm in write mode on a named graph.
[source, cypher, role=noplay]
----
CALL gds.alpha.spanningTree.mutate(
  graphName: String,
  configuration: Map
)
YIELD
      effectiveNodeCount: Integer,
      totalWeight: Float,
      relationshipsWritten: Integer,
      preProcessingMillis: Integer,
      computeMillis: Integer,
      mutateMillis: Integer,
      configuration: Map
----
include::partial$/algorithms/common-configuration/common-parameters.adoc[]

.Configuration
[opts="header",cols="1,1,1,1,4"]
|===
| Name                                                                             | Type    | Default   | Optional  | Description
| mutateProperty                                                                    | String  | 'mst'     | yes       | The relationship type used for the new relationships written to the projected graph.
| weightMutateProperty                                                              | String  | n/a       | no        | The weight property of the `mutateProperty` relationship type written back
include::partial$/algorithms/common-configuration/common-mutate-configuration-entries.adoc[]
include::partial$/algorithms/alpha/spanning-tree/specific-configuration.adoc[]
|===

.Results
[opts="header",cols="1,1,6"]
|===
| Name                | Type    | Description
| effectiveNodeCount  | Integer | The number of visited nodes.
| totalWeight         | Float   | The sum of the weights of the relationships in the spanning tree.
| relationshipsWritten |Integer | The number of relationships added to the in-memory graph.
| preProcessingMillis | Integer | Milliseconds for preprocessing the data.
| computeMillis       | Integer | Milliseconds for running the algorithm.
| mutateMillis         | Integer | Milliseconds for writing result data back.
| configuration         | Map       | The configuration used for running the algorithm.
|===
======
====
[[algorithms-minimum-weight-spanning-tree-sample]]
== Examples

image::mst.png[]

.The following will create the sample graph depicted in the figure:
[source, cypher, role=noplay]
----
CREATE (a:Place {id: 'A'}),
       (b:Place {id: 'B'}),
       (c:Place {id: 'C'}),
       (d:Place {id: 'D'}),
       (e:Place {id: 'E'}),
       (f:Place {id: 'F'}),
       (g:Place {id: 'G'}),
       (d)-[:LINK {cost:4}]->(b),
       (d)-[:LINK {cost:6}]->(e),
       (b)-[:LINK {cost:1}]->(a),
       (b)-[:LINK {cost:3}]->(c),
       (a)-[:LINK {cost:2}]->(c),
       (c)-[:LINK {cost:5}]->(e),
       (f)-[:LINK {cost:1}]->(g);
----

.The following will project and store a named graph:
[source, cypher, role=noplay]
----
CALL gds.graph.project(
  'graph',
  'Place',
  {
    LINK: {
      properties: 'cost',
      orientation: 'UNDIRECTED'
    }
  }
)
----
[[algorithms-spanning-tree-examples-memory-estimation]]
=== Memory Estimation

:mode: stats
include::partial$/algorithms/shared/examples-estimate-intro.adoc[]

[role=query-example]
--
.The following will estimate the memory requirements for running the algorithm in write mode:
[source, cypher, role=noplay]
----
MATCH (n:Place {id: 'D'})
CALL gds.alpha.spanningTree.stats.estimate('myGraph', {sourceNode: id(n),relationshipWriteProperty:'cost'})
YIELD
      nodeCount,
      relationshipCount,
      bytesMin,
      bytesMax,
      requiredMemory
----

.Results
[opts="header"]
|===
| nodeCount | relationshipCount | bytesMin | bytesMax | requiredMemory
| 7         | 14               | 568   | 568      | 568 Bytes"
|===
--

[[alpha-algorithms-spanning-tree-examples-write]]
=== Write


include::partial$/algorithms/shared/examples-write-intro.adoc[]

.The following will run the Minimum Weight Spanning Tree algorithm and mutate the in-memory graph.
[source, cypher, role=noplay]
----
MATCH (n:Place {id: 'D'})
CALL gds.alpha.spanningTree.write('graph', {
  sourceNode: id(n),
  relationshipWeightProperty: 'cost',
  writeProperty: 'MINST',
  weightWriteProperty: 'writeCost'
})
YIELD preProcessingMillis, computeMillis, writeMillis, effectiveNodeCount
RETURN preProcessingMillis, computeMillis, writeMillis, effectiveNodeCount;
----

.To find all pairs of nodes included in our minimum spanning tree, run the following query:
[source, cypher, role=noplay]
----
MATCH path = (n:Place {id: 'D'})-[:MINST*]-()
WITH relationships(path) AS rels
UNWIND rels AS rel
WITH DISTINCT rel AS rel
RETURN startNode(rel).id AS source, endNode(rel).id AS destination, rel.writeCost AS cost
----

.Results
image::minst_result.png[]

.Results
[opts="header",cols="1,1,1"]
|===
| Source | Destination | Cost
| D      | B           | 4
| B      | A           | 1
| A      | C           | 2
| C      | E           | 5
|===

The minimum spanning tree excludes the relationship with cost 6 from D to E, and the one with cost 3 from B to C.
Nodes F and G aren't included because they're unreachable from D.

Maximum weighted tree spanning algorithm is similar to the minimum one, except that it returns a spanning tree of all nodes in the component where the total weight of the relationships is maximized.

.The following will run the maximum weight spanning tree algorithm and write back results:
[source, cypher, role=noplay]
----
MATCH (n:Place{id: 'D'})
CALL gds.alpha.spanningTree.write('graph', {
  sourceNode: id(n),
  relationshipWeightProperty: 'cost',
  writeProperty: 'MAXST',
  weightWriteProperty: 'writeCost',
 objective: 'maximum'
})
YIELD preProcessingMillis, computeMillis, writeMillis, effectiveNodeCount
RETURN preProcessingMillis,computeMillis, writeMillis, effectiveNodeCount;
----

.Results
image::maxst_result.png[]

[[algorithms-spanning-tree-examples-mutate]]
=== Mutate


include::partial$/algorithms/shared/examples-mutate-intro.adoc[]

.The following will run the Minimum Weight Spanning Tree algorithm and write back results:
[source, cypher, role=noplay]
----
MATCH (n:Place {id: 'D'})
CALL gds.alpha.spanningTree.mutate('graph', {
  sourceNode: id(n),
  relationshipWeightProperty: 'cost',
  mutateProperty: 'MINST',
  weightMutateProperty: 'writeCost'
})
YIELD relationshipsWritten
RETURN relationshipsWritten
----
.Results
[opts="header"]
|===
| relationshipsWritten
| 4
|===

[[algorithms-spanning-tree-examples-stats]]
=== Stats
:stats-syntax: algorithms-minimum-weight-spanning-tree-syntax
include::partial$/algorithms/shared/examples-stats-intro.adoc[]

[role=query-example, no-result=true]
--
.The following will run the algorithm and returns the result in form of statistical and measurement values
[source,cypher,role=noplay]
----
MATCH (n:Place{id: 'D'})
CALL gds.alpha.spanningTree.stats('graph', {
  sourceNode: id(n),
  relationshipWeightProperty: 'cost',
 objective: 'mininum'
})
YIELD effectiveNodeCount
RETURN effectiveNodeCount
----

.Results
[opts="header",cols="1"]
|===
| effectiveNodeCount
| 5
|===
--
