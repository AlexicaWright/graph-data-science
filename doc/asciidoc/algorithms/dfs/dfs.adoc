[[algorithms-dfs]]
= Depth First Search
:entity: relationship

[abstract]
--
This section describes the Depth First Search traversal algorithm in the Neo4j Graph Data Science library.
--


[[algorithms-dfs-intro]]
== Introduction

The Depth First Search algorithm is a graph traversal that starts at a given node and explores as far as possible along each branch before backtracking, see https://en.wikipedia.org/wiki/Depth-first_search.
A related algorithm is the Breath First Search algorithm, <<algorithms-bfs, Breath First Search>>.
This algorithm can be preferred over Breath First Search for example if one wants to find a target node at a large distance and exploring a random path has decent probability of success.
There are multiple termination conditions supported for the traversal, based on either reaching one of several target nodes, reaching a maximum depth, exhausting a given budget of traversed relationship cost, or just traversing the whole graph.
The output of the procedure contains information about which nodes were visited and in what order.

[[algorithms-dfs-syntax]]
== Syntax
.Depth First Search syntax per mode
[.tabbed-example, caption = ]
====

[.include-with-stream]
======
.Run Depth First Search in stream mode:
[source, cypher, role=noplay]
----
CALL gds.dfs.stream(
  graphName: String,
  configuration: Map
)
YIELD
  sourceNode: Integer,
  nodeIds: Integer,
  path: Path
----

include::../common-configuration/common-parameters.adoc[]

include::../common-configuration/common-configuration.adoc[]

include::specific-configuration.adoc

.Results
[opts="header",cols="1,1,6"]
|===
| Name        | Type            | Description
| sourceNode  | Integer         | The node id of the node where to start the traversal.
| nodeIds     | List of Integer | The ids of all nodes that were visited during the traversal.
| path        | Path            | A path containing all the nodes that were visited during the traversal.
|===
======

[.include-with-mutate]
======
.Run Depth First Search in stream mode:
[source, cypher, role=noplay]
----
CALL gds.dfs.mutate(
  graphName: string,
  configuration: map
)
YIELD
  relationshipsWritten: Integer,
  preProcessingMillis: Integer,
  computeMillis: Integer,
  postProcessingMillis: Integer,
  mutateMillis: Integer,
  configuration: Map
----

include::../common-configuration/common-parameters.adoc[]

include::../common-configuration/common-mutate-configuration-named-graph.adoc[]

include::specific-configuration.adoc

.Results
[opts="header",cols="1,1,6"]
|===
| Name                   | Type      | Description
| preProcessingMillis    | Integer   | Milliseconds for preprocessing the graph.
| computeMillis          | Integer   | Milliseconds for running the algorithm.
| postProcessingMillis   | Integer   | Unused.
| mutateMillis           | Integer   | Milliseconds for adding relationships to the projected graph.
| relationshipsWritten   | Integer   | The number of relationships that were added.
| configuration          | Map       | The configuration used for running the algorithm.
|===
======

====

[[algorithms-dfs-examples]]
== Examples

Consider the graph created by the following Cypher statement:

[source, cypher, role=noplay setup-query]
----
CREATE
       (nA:Node {tag: 'a'}),
       (nB:Node {tag: 'b'}),
       (nC:Node {tag: 'c'}),
       (nD:Node {tag: 'd'}),
       (nE:Node {tag: 'e'}),

       (nA)-[:REL {cost: 8.0}]->(nB),
       (nA)-[:REL {cost: 9.0}]->(nC),
       (nB)-[:REL {cost: 1.0}]->(nE),
       (nC)-[:REL {cost: 5.0}]->(nD)
----

.The following statement will project the graph and store it in the graph catalog.
[source, cypher, role=noplay graph-project-query]
----
CALL gds.graph.project('myGraph', 'Node', 'REL', { relationshipProperties: 'cost' })
----

In the following examples we will demonstrate using the Depth First Search algorithm on this graph.
If we do not specify any of the options for early termination, the whole graph is visited:

[role=query-example]
--
.Running the Depth First Search algorithm:
[source, cypher, role=noplay]
----
MATCH (a:Node{tag:'a'})
WITH id(a) AS sourceNode
CALL gds.dfs.stream('myGraph', {sourceNode: sourceNode})
YIELD path
UNWIND [ n in nodes(path) | n.tag ] AS tags
RETURN tags
ORDER BY tags
----

.Results
[opts="header"]
|===
| tags
| "a"
| "b"
| "c"
| "d"
| "e"
|===
--

If specifying d and e as target nodes, not all nodes at distance 1 will be visited due to the depth first traversal order, in which node d is reached before b:

[role=query-example]
--
.Running the Depth First Search algorithm with target nodes:
[source, cypher, role=noplay]
----
MATCH (a:Node{tag:'a'}), (d:Node{tag:'d'}), (e:Node{tag:'e'})
WITH id(a) AS sourceNode, [id(d), id(e)] AS targetNodes
CALL gds.dfs.stream('myGraph', {sourceNode: sourceNode, targetNodes: targetNodes})
YIELD path
UNWIND [ n in nodes(path) | n.tag ] AS tags
RETURN tags
ORDER BY tags
----

.Results
[opts="header"]
|===
| tags
| "a"
| "c"
| "d"
|===
--


[role=query-example]
--
.Running the Depth First Search algorithm with maxDepth:
[source, cypher, role=noplay]
----
MATCH (a:Node{tag:'a'})
WITH id(a) AS sourceNode
CALL gds.dfs.stream('myGraph', {sourceNode: sourceNode, maxDepth: 1})
YIELD path
UNWIND [ n in nodes(path) | n.tag ] AS tags
RETURN tags
ORDER BY tags
----

.Results
[opts="header"]
|===
| tags
| "a"
| "b"
| "c"
|===
--

In the above case, nodes d and e were not visited since they are at distance 2 from a.
